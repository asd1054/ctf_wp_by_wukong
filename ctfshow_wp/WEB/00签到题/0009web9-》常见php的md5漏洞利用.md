访问后是登陆框界面，尝试注入，没有回显报错信息，其中用户名固定admin
尝试目录遍历，发现robots.txt,访问后即可下载index.phps，查看备份文件内容
```php



<?php
        $flag="";
		$password=$_POST['password'];
		if(strlen($password)>10){
			die("password error");
		}
		$sql="select * from user where username ='admin' and password ='".md5($password,true)."'";
		$result=mysqli_query($con,$sql);
			if(mysqli_num_rows($result)>0){
					while($row=mysqli_fetch_assoc($result)){
						 echo "登陆成功<br>";
						 echo $flag;
					 }
			}
    ?>


```
根据备份文件得知，只能对password进行注入
根据php的md5漏洞，可以寻找一个字符串使得转义后形成万能密码登陆
ffifdyop进行md5加密后，因第二个参数为true，会再进行一次ascii的转化，变成输出' or 6'乱码的结果，进而形成万能密码。

----
后台目录扫描 - 发现 index.phps 源代码文件

`dirsearch -u http://xxx.challenge.ctf.show`  获取 robot.txt
[22:19:41] 200 - 36B - /robots.txt 文件

访问 http://ecd136d7-8c30-4506-ae3b-8c50123c9ac1.challenge.ctf.show/robots.txt - 发现 index.phps 文件

访问 http://ecd136d7-8c30-4506-ae3b-8c50123c9ac1.challenge.ctf.show/index.phps - 发现自动下载了 index.phps

用 phpstorm 打开文件 - 发现源码中有 sql="select * from user where username ='admin' and password ='".md5($password,true)."'"; 即密码被 MD5 加密

对于函数 md5(string,raw) 第二个参数有以下可选项：TRUE - 原始 16 字符二进制格式 FALSE - 默认 32 字符十六进制数

MD5 加密后的 16 进制转化为二进制时有 'or'xxxx，即可构成闭合语句：username ='admin' and password =' 'or 'xxxxx' 成功登陆

两个符合的字符串：ffifdyop 129581926211651571912466741651878684928

题目有长度限制，输入 ffifdyop 获取 flag
ctfshow{a169a2c2-ad63-44d6-a41c-f0b1e679fc78}

测试万能密码和过滤绕过均没有回显
用kali dirsearch命令进行端口扫描发现robots.txt，查看发现index.php文件
获取index.php进行代码审计发现有MD5 SQL绕过漏洞，密码输入ffifdyop成功获取flag
常见MD5漏洞请看MD5漏洞


----




          
好的，我们来详细分析这段PHP代码，并探讨如何进行SQL注入。

### PHP 代码解释

```php
<?php 
         $flag=""; // 初始化一个空字符串变量 $flag，但在此代码段中未被赋值，其值可能来自其他地方或是一个占位符。
 	 	 $password=$_POST['password']; // 从HTTP POST请求中获取名为 'password' 的参数值，并赋给 $password 变量。
 	 	 if(strlen($password)>10){ // 检查 $password 字符串的长度。
 	 	 	 die("password error"); // 如果密码长度超过10个字符，则终止脚本执行并输出 "password error"。
 	 	 } 
 	 	 // 构造SQL查询语句
 	 	 // 注意：md5($password, true) 会将密码进行MD5哈希，并返回16字节的原始二进制字符串。
 	 	 // 这个二进制字符串直接拼接到SQL查询中，并被单引号包围。
 	 	 $sql="select * from user where username ='admin' and password ='".md5($password,true)."'"; 
 	 	 $result=mysqli_query($con,$sql); // 执行SQL查询。$con 变量未定义，假设它是一个已建立的数据库连接。
 	 	 	 if(mysqli_num_rows($result)>0){ // 检查查询结果的行数是否大于0。
 	 	 	 	 	 while($row=mysqli_fetch_assoc($result)){ // 如果有结果，遍历每一行。
 	 	 	 	 	 	  echo "登陆成功<br>"; // 输出 "登陆成功"。
 	 	 	 	 	 	  echo $flag; // 输出 $flag 变量的值。
 	 	 	 	 	  } 
 	 	 	 } 
     ?> 
```

**代码功能概述：**

这段PHP代码实现了一个简单的用户登录验证功能。它从POST请求中获取用户输入的密码，并对密码长度进行限制（不能超过10个字符）。然后，它将用户输入的密码进行MD5哈希（以原始二进制格式），并将其拼接到一个SQL查询语句中，用于验证 `username` 为 'admin' 的用户。如果查询结果返回了数据，则表示登录成功，并输出 "登陆成功" 和 `$flag` 的值。

### 漏洞分析

这段代码存在明显的SQL注入漏洞，主要原因在于：

1.  **用户输入 `$password` 未经充分过滤和转义就直接拼接到SQL查询中。**
2.  **`md5($password, true)` 的使用方式。** `md5()` 函数的第二个参数设置为 `true` 时，它会返回一个16字节的原始二进制字符串，而不是常见的32字符十六进制字符串。当这个二进制字符串被直接放入SQL的单引号中时，如果其中包含SQL的特殊字符（尤其是单引号 `'`），就可能导致SQL注入。

**`strlen($password)>10` 的限制：** 这个限制意味着我们输入的密码字符串不能超过10个字符。这增加了寻找特定MD5哈希的难度，但并非不可绕过。

### SQL 注入方法

核心思路是利用 `md5($password, true)` 生成的二进制字符串中可能包含的特殊字符来破坏SQL语句的结构。

#### 1. 核心注入思路：利用原始MD5哈希中的单引号 (`'`)

**原理：**
如果我们可以找到一个密码 `P` (长度小于等于10)，它的原始MD5哈希 `md5(P, true)` 中包含一个单引号字符 (`0x27`)，并且这个单引号后面跟着我们构造的SQL注入语句，那么我们就可以绕过密码验证。

假设我们找到一个密码 `P`，其 `md5(P, true)` 的二进制输出是 `[前缀二进制数据] + \x27 + [注入Payload] + [后缀二进制数据]`。
那么，原始的SQL查询语句：
`select * from user where username ='admin' and password ='".md5($password,true)."'"`
就会变成：
`select * from user where username ='admin' and password ='[前缀二进制数据]'[注入Payload]'[后缀二进制数据]'`

如果 `[注入Payload]` 是 `OR 1=1 -- `，那么SQL语句就会变成：
`select * from user where username ='admin' and password ='[前缀二进制数据]' OR 1=1 -- '[后缀二进制数据]'`

*   `'admin'` 条件保持不变。
*   `password ='[前缀二进制数据]'` 仍然是一个字符串比较。
*   `OR 1=1` 会使整个 `WHERE` 子句变为真，因为 `1=1` 永远为真。
*   `-- ` 是SQL注释符，它会注释掉后面的 `'[后缀二进制数据]'`，避免语法错误。

这样，无论 `admin` 用户的真实密码是什么，只要 `username ='admin'` 成立，并且我们成功注入 `OR 1=1`，登录就会成功。

**如何找到这样的密码 `P`？**

这是一个被称为 "MD5原始输出SQL注入" 或 "二进制字符串SQL注入" 的高级技巧。它需要找到一个短字符串 `P`，其MD5原始哈希的第 `k` 个字节是 `0x27` (单引号的ASCII值)，并且从第 `k+1` 个字节开始的序列能够构成有效的SQL注入Payload（例如 `OR 1=1 -- `）。

*   **挑战：** 找到这样的密码 `P` 极其困难，通常需要进行大量的计算（暴力破解或使用专门的工具）来寻找MD5碰撞，使其原始输出满足特定条件。由于MD5哈希是伪随机的，手动构造几乎不可能。
*   **长度限制：** 密码长度不能超过10个字符，这进一步限制了寻找的范围。

**示例 (假设存在这样的密码)：**

假设我们通过某种方法找到了一个密码 `P` (例如 `test_pass`)，其长度小于等于10，并且 `md5("test_pass", true)` 的原始二进制输出恰好是：
`\x00\x01\x02\x03\x04\x05\x06\x07\x27OR 1=1 -- \x00\x00\x00` (这是一个**假设的**MD5原始输出，实际中很难找到)

那么，当 `$password = "test_pass"` 时，SQL语句会变为：
`select * from user where username ='admin' and password ='\x00\x01\x02\x03\x04\x05\x06\x07' OR 1=1 -- \x00\x00\x00'`

这样，`admin` 用户就可以成功登录。

#### 2. 其他可能的（但在此场景下不太适用或更难的）注入思路

*   **PHP弱类型比较 (Magic Hashes)：**
    *   **原理：** 这种方法通常用于 `md5($password)` (非原始输出) 的情况。PHP在进行松散比较（`==`）时，如果一个字符串以 `0e` 开头且后面全是数字，PHP会将其视为科学计数法，并将其值视为 `0`。如果数据库中存储的密码哈希也是 `0e...` 形式，那么 `md5("240610708")` 的哈希是 `0e462097431906509019562988736854`，在PHP中与 `0` 相等。如果 `admin` 的密码哈希在数据库中也是 `0e...` 形式，就可以绕过。
    *   **不适用原因：** 在本例中，`md5($password, true)` 返回的是原始二进制字符串，它不会产生 `0e...` 这种形式的字符串，并且SQL查询中是字符串精确匹配（`=`），而不是PHP的弱类型比较。所以这种方法不直接适用。

*   **宽字节注入 (GBK编码)：**
    *   **原理：** 在某些使用GBK等宽字节编码的数据库和PHP配置中，如果PHP的 `addslashes()` 或 `mysqli_real_escape_string()` 函数只对单字节的 `\` 进行转义，而没有考虑宽字节字符，攻击者可以输入一个 `0xbf` 这样的宽字节字符，与 `\` 结合形成一个合法的宽字节字符，从而使后面的单引号逃逸。
    *   **不适用原因：** 本例中没有使用 `addslashes()` 或 `mysqli_real_escape_string()` 对 `md5($password, true)` 的结果进行转义，而是直接拼接。因此，宽字节注入的机制不直接适用，但如果原始MD5输出中包含 `0xbf27` 这样的序列，且数据库是GBK编码，则可能触发。

### 防御措施

为了防止此类SQL注入漏洞，最根本的解决方案是：

1.  **使用预处理语句 (Prepared Statements)：** 这是最推荐和最安全的做法。使用 `mysqli_prepare()` 和 `mysqli_stmt_bind_param()` 来将用户输入作为参数绑定到SQL查询中，而不是直接拼接到字符串中。这样，数据库驱动会负责正确地转义所有特殊字符，从而彻底杜绝SQL注入。
2.  **对用户输入进行严格的过滤和转义：** 如果无法使用预处理语句，则必须对所有用户输入进行严格的过滤（例如，只允许数字、字母）和转义（例如，使用 `mysqli_real_escape_string()`）。但这种方法容易出错且不推荐。

总之，这段代码的漏洞点在于将 `md5($password, true)` 的原始二进制输出直接拼接到SQL查询中，为攻击者提供了利用二进制字符串中特殊字符进行SQL注入的机会。

---




          
好的，PHP中与MD5相关的漏洞主要集中在MD5哈希函数的特性、PHP的弱类型比较机制以及MD5函数的使用方式上。以下是几种常见的MD5漏洞及其利用方法：

### 1. MD5 弱类型比较漏洞 (Type Juggling / Magic Hashes)

这是PHP中最常见且最容易利用的MD5相关漏洞之一。

*   **原理：**
    当PHP在进行松散比较（`==`）时，如果一个字符串以 `0e` 开头，并且后面跟着的全部是数字，PHP会将其视为科学计数法，并将其值解释为 `0`。如果两个这样的字符串进行 `==` 比较，它们都会被转换为 `0`，从而导致比较结果为真。
    例如，`"0e123"` 和 `"0e456"` 在 `==` 比较时都会被视为 `0`，所以 `"0e123" == "0e456"` 的结果是 `true`。
    攻击者可以利用MD5哈希值中存在以 `0e` 开头且后面全是数字的特殊字符串。

*   **常见场景：**
    通常发生在用户密码验证时，如果代码使用 `md5($input) == $stored_hash` 进行比较，并且 `$stored_hash` 是一个以 `0e` 开头且后面全是数字的MD5哈希值。

*   **利用方法：**
    攻击者需要找到一个字符串，其MD5哈希值以 `0e` 开头，并且后面全是数字。
    例如，`240610708` 这个字符串的MD5哈希是 `0e462097431906509019562988736854`。
    如果数据库中存储的密码哈希是 `0e...` 形式，那么攻击者输入 `240610708` 作为密码，`md5("240610708")` 就会得到 `0e462097431906509019562988736854`。
    如果代码是 `if (md5($input_password) == $stored_hash)`，并且 `$stored_hash` 也是一个 `0e...` 形式的哈希，那么比较就会成功。

*   **示例代码 (存在漏洞)：**

    ```php
    <?php
    $password = $_POST['password'];
    $stored_hash = "0e462097431906509019562988736854"; // 假设这是admin用户的密码哈希

    if (md5($password) == $stored_hash) { // 使用 == 进行松散比较
        echo "Login successful!";
    } else {
        echo "Login failed.";
    }
    ?>
    ```

*   **如何利用：**
    攻击者提交 `password=240610708`，`md5("240610708")` 得到 `0e462097431906509019562988736854`。
    `"0e462097431906509019562988736854" == "0e462097431906509019562988736854"` 结果为 `true`，登录成功。
    还有其他很多字符串的MD5哈希也是 `0e...` 形式，例如：
    `s878926199a` -> `0e545993274517709034328855941067`
    `s155964671a` -> `0e342768416904560094159368951594`

*   **防御方法：**
    始终使用**严格比较** `===` 来比较哈希值，因为 `===` 会同时比较值和类型，不会触发弱类型转换。

### 2. MD5 原始输出导致的 SQL 注入 (Raw MD5 Output SQL Injection)

这正是我们之前讨论的场景。

*   **原理：**
    当 `md5()` 函数的第二个参数设置为 `true` 时，它会返回一个16字节的原始二进制字符串。如果这个二进制字符串直接拼接到SQL查询中，并且其中包含SQL的特殊字符（如单引号 `'`、反斜杠 `\` 等），就可能导致SQL注入。

*   **常见场景：**
    当PHP代码将 `md5($password, true)` 的结果直接嵌入到SQL查询的单引号字符串中，而没有进行适当的转义时。

*   **利用方法：**
    攻击者需要找到一个短字符串 `P`，其 `md5(P, true)` 的原始二进制输出中包含一个单引号字符 (`0x27`)，并且 `0x27` 后面能够构造出有效的SQL注入Payload。
    例如，如果 `md5(P, true)` 的输出是 `... \x27 OR 1=1 -- ...`，那么SQL语句就会被注入。

*   **示例代码 (存在漏洞)：**

    ```php
    <?php
    $password = $_POST['password'];
    // 假设 $password 长度限制在10以内
    if (strlen($password) > 10) {
        die("password error");
    }
    // 直接拼接原始MD5哈希到SQL查询中
    $sql = "select * from user where username ='admin' and password ='" . md5($password, true) . "'";
    // ... 执行SQL查询 ...
    ?>
    ```

*   **如何利用：**
    寻找一个字符串 `P`，使得 `md5(P, true)` 的原始二进制输出中包含 `0x27`，并且 `0x27` 之后的部分能构成注入语句。
    例如，通过暴力破解或专门的工具，找到一个 `P`，其 `md5(P, true)` 包含 `\x27 OR 1=1 -- `。
    一个著名的例子是 `ffifdyop`，其MD5哈希是 `278d04e9746ee7230000000000000000`。虽然这个不是原始二进制，但如果原始二进制输出中包含 `0x27`，则可以利用。
    寻找这种碰撞非常困难，通常需要专门的工具或预计算的哈希表。

*   **防御方法：**
    *   **使用预处理语句 (Prepared Statements)：** 这是最根本的防御方法，将用户输入作为参数绑定，而不是直接拼接。
    *   **对 `md5($password, true)` 的结果进行转义：** 如果必须使用原始二进制输出并拼接，则需要使用 `mysqli_real_escape_string()` 或 PDO 的 `quote()` 方法对其进行转义，但这种做法非常危险且容易出错，强烈不推荐。
    *   **避免使用 `md5($password, true)` 直接进行密码验证：** 密码哈希应该使用更安全的算法（如 `password_hash()`）并存储为可打印的字符串。

### 3. MD5 碰撞 (Collision)

*   **原理：**
    MD5是一种哈希函数，理论上不同的输入可能会产生相同的输出（哈希碰撞）。虽然MD5被认为是弱哈希算法，但找到两个任意输入产生相同MD5哈希的碰撞（即“第二原像攻击”或“生日攻击”）在计算上仍然是昂贵的，尤其是在实际的Web应用中。

*   **常见场景：**
    在文件完整性校验、数字签名等场景中，如果攻击者能够提供一个与合法文件MD5值相同的恶意文件，就可能绕过校验。在密码学中，如果两个不同的密码哈希值相同，也可能导致问题。

*   **利用方法：**
    对于密码验证，如果攻击者能够找到一个与合法用户密码哈希值相同的另一个密码，就可以冒充该用户。然而，由于MD5的计算特性，找到一个与已知哈希值相同的**任意**输入（第二原像攻击）仍然非常困难。找到两个**任意**输入产生相同哈希（生日攻击）相对容易，但通常不适用于直接的密码验证场景。

*   **防御方法：**
    *   **不将MD5用于密码存储：** 密码应该使用更安全的哈希算法，如 bcrypt、scrypt、Argon2，这些算法设计时就考虑了抗碰撞和抗暴力破解。
    *   **加盐 (Salting)：** 即使使用MD5，也应该为每个用户生成一个唯一的随机盐值，然后计算 `md5(password + salt)`。这样即使发生MD5碰撞，也需要为每个用户单独计算，大大增加了攻击难度。

### 4. MD5 长度扩展攻击 (Length Extension Attack)

*   **原理：**
    MD5是一种基于Merkle-Damgård结构的哈希函数。如果攻击者知道 `hash(secret + message1)` 的值，并且知道 `secret` 的长度，那么他可以在不知道 `secret` 的情况下，计算出 `hash(secret + message1 + padding + message2)` 的值。

*   **常见场景：**
    当MD5用于消息认证码 (MAC) 时，例如 `md5(secret_key + data)`，并且服务器使用这种方式来验证数据的完整性和来源。

*   **利用方法：**
    假设服务器使用 `md5(key + message)` 来生成一个令牌。攻击者截获了 `message` 和 `token = md5(key + message)`。如果攻击者知道 `key` 的长度，他就可以构造一个新的 `message'`，并计算出 `md5(key + message')`，而无需知道 `key` 的实际值。

*   **防御方法：**
    *   **不将MD5用于消息认证码：** 应该使用HMAC-MD5（或更推荐的HMAC-SHA256等），HMAC结构可以有效防御长度扩展攻击。
    *   **将密钥放在消息的末尾：** `md5(message + secret_key)` 也可以防御长度扩展攻击，但不如HMAC安全。

### 总结

在PHP开发中，为了避免MD5相关的安全漏洞：

1.  **密码存储：** 绝不使用MD5（即使加盐），应使用 `password_hash()` 函数和更强的哈希算法（如 bcrypt）。
2.  **哈希比较：** 始终使用严格比较 `===` 来比较哈希值，避免弱类型比较漏洞。
3.  **SQL查询：** 始终使用预处理语句（Prepared Statements）来处理所有用户输入，彻底杜绝SQL注入。
4.  **消息认证：** 使用HMAC系列算法（如 `hash_hmac()`），而不是简单的 `md5()` 拼接。

理解这些漏洞的原理和利用方式，有助于开发者编写更安全的PHP代码。
        