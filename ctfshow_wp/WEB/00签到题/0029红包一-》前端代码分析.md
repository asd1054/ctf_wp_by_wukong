# CTF解题报告：红包一 - 前端代码分析

  

## 题目信息

- **题目名称：** 红包一

- **目标网址：** http://1c57075d-a26a-495e-aa5e-a3088264c11f.challenge.ctf.show/

- **最终Flag：** ctfshow{Happy_Birthday_My_Country}

  

## 漏洞分析

  

### 页面结构分析

页面包含：

1. 加载动画效果

2. 混淆的JavaScript代码

3. CSS文件引用

  

### JavaScript代码分析

通过分析发现关键函数：

  

```javascript

function getflag(){

const _0x51954c=_0x2122;

console[_0x51954c(0x7f)](_0x51954c(0x7c));

}

  

function go(_0x554bbc){

// ... 处理逻辑

_0x554bbc==0xb&&(console[_0x4636e4(0x89)](),getflag());

}

  

function FBIWarning(){

for(var _0x5f55aa=0x1;_0x5f55aa<=0xb;_0x5f55aa++){

setTimeout(_0x4d4a2a(0x83)+_0x5f55aa+')',_0x5f55aa+_0x4d4a2a(0x7d));

}

console['clear']();

}

```

  

### 反调试机制

```javascript

!function(){

const _0x3bcc60=setInterval(()=>{

const _0x47d54b=_0x2122,_0x359297=new Date()[_0x47d54b(0x80)]();

debugger; // 反调试断点

const _0x4ce7dc=new Date()[_0x47d54b(0x80)]();

Math[_0x47d54b(0x8e)](_0x4ce7dc-_0x359297)>0x64&&(FBIWarning(),clearInterval(_0x3bcc60));

},0x3e8);

}();

```

  

## 攻击步骤

  

### Step 1: 信息收集

```bash

curl -s "http://1c57075d-a26a-495e-aa5e-a3088264c11f.challenge.ctf.show/"

```

  

### Step 2: 直接提取Flag

```bash

curl -s "http://1c57075d-a26a-495e-aa5e-a3088264c11f.challenge.ctf.show/" | grep -o "ctfshow{[^}]*}"

```

  

### Step 3: 获取结果

```

ctfshow{Happy_Birthday_My_Country}

```

  

## 技术细节

  

### 混淆代码分析

JavaScript代码使用了以下混淆技术：

1. 数组混淆：将字符串存储在数组中

2. 函数名混淆：使用十六进制函数名

3. 控制流混淆：复杂的调用链

  

### Flag位置

Flag直接硬编码在混淆的JavaScript代码中：

```javascript

const _0x4b06d7=['padding:100px\x20120px;\x20font-size:\x200;\x20background:url(\x22','%c\x20','4794822nLKJYA','.gif','clear','18xdjAAC','port','407235uHwfGL','location','abs','2698131HgmvDV','486zMsipS','6172276GysvKv','700496gKdPdS','ctfshow{Happy_Birthday_My_Country}','500','log','error','getTime','5907iOEsVM','\x22);\x20no-repeat;','go(','7185675nyCjVD'];

```

  

### 预期解题思路

题目设计者预期的解题思路：

1. 绕过反调试机制

2. 等待FBIWarning()函数执行

3. 当go(11)被调用时触发getflag()

4. 在控制台查看flag输出

  

### 实际简化解法

由于flag直接暴露在源码中，可以直接通过文本处理工具提取，无需绕过任何保护机制。

  

## 防御建议

  

### 代码混淆改进

```javascript

// 不要将flag直接硬编码在前端

// 应该通过API动态获取或使用服务器端验证

  

// 改进方案：服务器端验证

function getFlagFromServer() {

fetch('/api/flag')

.then(response => response.json())

.then(data => console.log(data.flag));

}

```

  

### 反调试机制加强

```javascript

// 使用更复杂的反调试技术

(function() {

var devtools = {

open: false,

orientation: null

};

var threshold = 160;

setInterval(function() {

if (window.outerHeight - window.innerHeight > threshold ||

window.outerWidth - window.innerWidth > threshold) {

if (!devtools.open) {

devtools.open = true;

// 反调试措施

}

} else {

devtools.open = false;

}

}, 500);

})();

```

  

## 总结

  

这个题目展示了前端安全中的几个重要概念：

  

1. **代码混淆的局限性**：即使代码被混淆，敏感信息仍可能被提取

2. **客户端安全的脆弱性**：任何存储在前端的敏感信息都是不安全的

3. **反调试机制的绕过**：反调试机制只能增加攻击难度，无法完全阻止

  

**关键学习点：**

- 永远不要在前端代码中硬编码敏感信息

- 代码混淆只能提高逆向难度，不能保证安全

- 重要的业务逻辑和验证应该在服务器端完成

  

**最终Flag：** ctfshow{Happy_Birthday_My_Country}