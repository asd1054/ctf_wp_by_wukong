要点：割割割割割割割割割割割割割割割割割割割割割割割割割割割割割割割割割割割


扫描发现www.zip源代码，发现flag的放出，需要密码等于admin用户的密码才能成功

这道题开始，破天荒的使用AI工具自动搜索答题找出flag，工具为：iflow
提示词
```
http://df1aad11-672d-432a-800d-1d5ea05a0dcd.challenge.ctf.show 这个就是我需要攻破的网址,请你根据源代码自行测试攻击,等你找到flag值之后再总结出你的攻击思路和具体步骤给我,其中为避免你反复重复做过的事情,请把你的思考和交互的过程都记录在log文件夹中,方便你回溯，其中源代码中的？？？就说明这个值是假的，代码对关键地方做了隐藏，请你不要进行sql注入，checklogin.php对登录验证进行了严格的输入过滤，防止SQL注入攻击。但是checkreg.php对注册验证没有进行严格的输入过滤，对password字段没有进行任何过滤，存在安全风险。请你结合这两个php文件，以及sql的漏洞，分析一下怎么才能借用admin登陆成功后查看flag值呢？一定是发现flag的准确值才能停止思考，必要的时候可以搜索【红包题 辟邪剑谱 ctfshow】来寻找其他人的解题思路
```
关键词允许搜索，且给出了明确的关键词搜素，方便快速找到解题思路

根据解析得知sql有隐藏漏洞，添加空格可以正常插入，查询的时候又会吃掉空格，以及空格后加一个字符插入，再查询的时候会因为空格足够多来进行截断。所以注册一个额外的用户密码，从而使得原来的admin的密码为自行注册的密码，从而绕过登陆限制。

----

# CTFShow Web117 详细Writeup报告

  

## 1. 题目概述

  

本题是一个CTF Web安全挑战，目标是通过分析源代码找出安全漏洞，绕过安全机制获取flag。

  

### 1.1 环境信息

- 目标网站: http://df1aad11-672d-432a-800d-1d5ea05a0dcd.challenge.ctf.show

- 源代码文件: checklogin.php, checkreg.php, inc/inc.php, inc/CTFSHOW.php

  

### 1.2 功能分析

- index.php: 登录和注册界面

- checklogin.php: 处理登录请求

- checkreg.php: 处理注册请求

- inc/inc.php: 数据库连接和初始化

- inc/CTFSHOW.php: 自定义数据库操作类

  

## 2. 源代码分析

  

### 2.1 CTFSHOW.php 数据库操作类分析

  

#### 2.1.1 类结构

该类实现了基本的数据库操作功能，包括：

- select(): 查询数据

- insert(): 插入数据

- update(): 更新数据

- delete(): 删除数据

  

#### 2.1.2 核心方法实现

  

##### select() 方法

```php

public function select($table, $join, $columns = null, $where = null)

{

// 构建查询语句

$query = $this->exec($this->selectContext($table, $map, $join, $columns, $where), $map);

// 执行查询并返回结果

}

```

  

##### insert() 方法

```php

public function insert($table, $datas)

{

// 构建插入语句

return $this->exec('INSERT INTO ' . $this->tableQuote($table) . ' (' . implode(', ', $fields) . ') VALUES ' . implode(', ', $stack), $map);

}

```

  

##### whereClause() 方法 (过滤条件构建)

该方法负责构建SQL查询的WHERE子句，包含安全过滤机制。

  

### 2.2 inc/inc.php 初始化文件

  

```php

<?php

@error_reporting(E_ERROR);

use \CTFSHOW\CTFSHOW;

require_once 'CTFSHOW.php';

session_start();

$flag = "flag_here";

$db = new CTFSHOW([

'database_type' => 'mysql',

'database_name' => 'ctf',

'server' => 'localhost',

'username' => 'root',

'password' => 'phpcj',

'charset' => 'utf8',

'port' => 3306,

'prefix' => '',

'option' => [

PDO::ATTR_CASE => PDO::CASE_NATURAL

]

]);

```

  

### 2.3 checkreg.php 注册处理文件

  

```php

<?php

require_once '/inc/inc.php';

$user_name=trim($_POST['user_name']);

$user_password=trim($_POST['user_password']);

$data=$db->select("admin",["username","password"],["username[=]"=>$user_name]);

if(count($data)>0){

die("username in use!");

}

if($user_name==="admin"){

die("you are not admin!");

}

if(preg_match("/select|update|drop|union|and|or|sys|substr|sleep|from|where|0x|hex|bin|char|file|order|limit|by|\`|\~|\!|\@|\#|\\$|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\+|\=|\{|\[|\}|\]|\;|\:|\'|\"|\<|\,|\>|\.|\?/i",$user_name)){

die("stop hack!");

}

$data = $db->insert('admin',["username"=>"$user_name","password"=>"$user_password"]);

if($data>0){

header("location:index.php");

}else{

die("error!");

}

```

  

### 2.4 checklogin.php 登录处理文件

  

```php

<?php

require_once '/inc/inc.php';

$user_name=trim($_POST['user_name']);

$user_password=trim($_POST['user_password']);

if(preg_match("/select|update|drop|union|and|or|sys|substr|sleep|from|where|0x|hex|bin|char|file|order|limit|by|\`|\~|\!|\@|\#|\\$|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\+|\=|\{|\[|\}|\]|\;|\:|\'|\"|\<|\,|\>|\.|\?/i",$user_name)){

die("stop hack!");

}

if(preg_match("/select|update|drop|union|and|or|sys|substr|sleep|from|where|0x|hex|bin|char|file|order|limit|by|\`|\~|\!|\@|\#|\\$|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\+|\=|\{|\[|\}|\]|\;|\:|\'|\"|\<|\,|\>|\.|\?/i",$user_password)){

die("stop hack!");

}

  

$data=$db->select("admin",["username","password"],["username[=]"=>"admin");

foreach($data as $d){

if ($d['password']===$user_password){

$_SESSION['user']=$user_name;

die("login success!<br><hr>flag is $flag");

}

}

header("location:index.php");

```

  

## 3. 安全机制分析

  

### 3.1 输入过滤机制

两个文件都使用了相同的正则表达式对用户名和密码进行过滤：

```php

preg_match("/select|update|drop|union|and|or|sys|substr|sleep|from|where|0x|hex|bin|char|file|order|limit|by|\`|\~|\!|\@|\#|\\$|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\+|\=|\{|\[|\}|\]|\;|\:|\'|\"|\<|\,|\>|\.|\?/i",$user_name)

```

  

这个过滤器阻止了大部分SQL注入攻击向量。

  

### 3.2 登录验证逻辑

在checklogin.php中，登录验证逻辑如下：

1. 对用户名和密码进行严格过滤

2. 查询admin表中username为"admin"的记录

3. 使用严格比较运算符(===)验证密码

  

### 3.3 注册安全机制

在checkreg.php中，注册安全机制包括：

1. 检查用户名是否已存在

2. 禁止注册"admin"用户名

3. 对用户名进行严格过滤

4. 但对密码字段没有进行任何过滤

  

## 4. 漏洞分析

  

### 4.1 关键漏洞点

虽然checkreg.php对用户名进行了严格过滤，但对密码字段没有进行任何过滤，这为攻击提供了突破口。

  

### 4.2 攻击思路

由于无法直接注册admin用户，也无法通过SQL注入绕过登录验证，我们需要寻找其他方法来获取flag。

  

通过搜索"红包题 辟邪剑谱 ctfshow"找到了相关解题思路，发现可以利用MySQL的字符串截断特性。

  

## 5. MySQL字符串截断攻击原理

  

### 5.1 原理说明

MySQL在处理字符串时，当字符串长度超过字段定义的长度时，会发生截断。例如：

- 如果字段定义为VARCHAR(10)，插入"12345678901"会被截断为"1234567890"

  

在MySQL中，当sql_mode没有设置STRICT_TRANS_TABLES或TRADITIONAL模式时，插入超长字符串只会产生警告而不是错误，这为攻击提供了可能。

  

### 5.2 利用方式

在本题中，我们可以利用以下特性：

1. MySQL在处理字符串时会忽略末尾的空白字符

2. 当字符串长度超过字段长度时会发生截断

3. 结合这两种特性可以绕过用户名检查

  

### 5.3 实际利用

通过注册用户名为"admin a"（admin后面跟若干空格再跟一个字符），可以绕过：

1. 用户名检查（不等于"admin"）

2. 正则表达式过滤（不包含禁用字符）

3. 数据库截断（空格被忽略，实际存储为"admin"）

  

当我们在VARCHAR(5)的字段中插入"admsddsff"时，由于长度限制，数据会被截断。如果我们构造一个特殊的用户名，在admin后面添加足够多的空格，然后再添加一个字符，这样在插入数据库时，由于字段长度限制，末尾的字符会被截断，而空格也会被忽略，最终在数据库中存储的就只是"admin"。

  

在CTFSHOW类中，虽然使用了PDO预处理语句，但仍然无法防止这种由于MySQL特性导致的截断攻击。

  

## 6. 完整攻击步骤

  

### 6.1 攻击准备

1. 分析源代码，找出安全机制和漏洞点

2. 确认checkreg.php对密码字段没有过滤

3. 查找相关解题思路，发现MySQL字符串截断特性

4. 确认目标环境中MySQL的sql_mode设置允许字符串截断

  

### 6.2 攻击实施

1. 注册特殊用户名：

```bash

curl -X POST http://df1aad11-672d-432a-800d-1d5ea05a0dcd.challenge.ctf.show/checkreg.php -d "user_name=admin a&user_password=admin123"

```

2. 使用注册的密码登录：

```bash

curl -X POST http://df1aad11-672d-432a-800d-1d5ea05a0dcd.challenge.ctf.show/checklogin.php -d "user_name=admin&user_password=admin123"

```

在注册时，我们使用了"admin a"作为用户名（admin后面跟空格足够长和一个字符任意字符）。由于数据库中admin表的username字段长度限制，当这个用户名被插入数据库时，末尾的"a"会被截断，而空格也会被MySQL忽略，最终在数据库中存储的用户名就是"admin"。

  

在登录时，我们使用"admin"作为用户名，这样在checklogin.php中查询数据库时就能匹配到我们插入的记录。然后我们使用注册时设置的密码"admin123"进行验证，就能成功登录并获取flag。

  

### 6.3 攻击结果

成功获取flag: ctfshow{b638d555-53fc-468f-adfc-9124c5927f8d}

  

## 7. 防护建议

  

### 7.1 输入验证

1. 对所有用户输入进行严格验证

2. 对用户名和密码都进行过滤检查

3. 限制输入长度，防止字符串截断攻击

  

### 7.2 数据库设计

1. 合理设置字段长度

2. 使用适当的数据库配置防止字符串截断

3. 在应用层验证数据长度

  

### 7.3 安全编码

1. 统一安全检查逻辑

2. 避免在不同地方使用不同的验证规则

3. 对敏感操作进行额外验证

  

## 8. 总结

  

本题通过一个看似安全的登录注册系统，展示了在实际开发中容易忽视的安全问题。虽然大部分安全机制都得到了正确实现，但对密码字段的疏忽导致了整个系统的安全性被破坏。

  

通过这次挑战，我们学到了：

1. 安全检查必须全面，不能有任何遗漏

2. MySQL的一些特性可能被恶意利用

3. 在安全编码中需要考虑各种边界情况

-----

          
现在我已经完成了对代码的全面安全审计，识别出所有潜在的安全风险。以下是我发现的所有漏洞、攻击步骤、具体思路和payload：

### 1. 用户认证逻辑漏洞

**漏洞描述：**
在`checklogin.php`中，登录验证逻辑存在严重缺陷。代码中硬编码了查询条件`["username[=]"=>"admin"]`，这意味着无论用户输入什么用户名，系统都只会查询admin用户的信息。只要输入的密码与数据库中admin用户的密码匹配，就可以成功登录。

**攻击步骤：**
1. 访问登录页面
2. 在用户名字段输入任意内容（如"test"）
3. 在密码字段输入admin用户的密码
4. 提交表单即可成功登录

**具体思路：**
攻击者可以绕过用户名验证，只需要知道admin用户的密码即可登录系统。

**Payload：**
```
用户名: test
密码: [admin用户的密码]
```

### 2. SQL注入防护不完善

**漏洞描述：**
虽然系统使用了参数化查询，但在`checkreg.php`中存在硬编码的"admin"判断逻辑，这可能导致逻辑上的安全问题。此外，`checklogin.php`中的硬编码查询条件也暴露了系统设计上的缺陷。

**攻击步骤：**
虽然参数化查询防止了传统的SQL注入，但硬编码的查询条件使得攻击者可以绕过用户名验证。

**具体思路：**
攻击者可以利用硬编码的查询条件绕过用户名验证，只需要提供正确的密码即可。

### 3. 正则表达式过滤规则可被绕过

**漏洞描述：**
在`checklogin.php`和`checkreg.php`中，使用了正则表达式来过滤用户输入。然而，这些过滤规则可以通过以下方式绕过：
1. 大小写混合（如"SeLeCt"）
2. URL编码（如"%73%65%6c%65%63%74"）
3. 注释符（如"sel/**/ect"）

**攻击步骤：**
1. 构造包含被过滤关键字但使用大小写混合的payload
2. 或使用URL编码绕过过滤
3. 或使用注释符分割关键字

**具体思路：**
通过变换输入格式绕过正则表达式过滤，为进一步攻击做准备。

**Payload示例：**
```
用户名: SeLeCt
密码: %73%65%6c%65%63%74
```

### 4. 密码明文存储风险

**漏洞描述：**
在`checkreg.php`中，用户密码以明文形式存储到数据库中，没有任何加密或哈希处理。这使得数据库一旦泄露，所有用户密码都将直接暴露。

**攻击步骤：**
1. 如果能访问数据库，直接读取admin表中的密码字段
2. 获取到的密码可直接用于登录

**具体思路：**
明文存储密码是严重的安全隐患，一旦数据库被入侵，攻击者可直接获取所有用户密码。

### 5. 会话管理简单易被劫持

**漏洞描述：**
在`checklogin.php`中，登录成功后仅将用户名存储在`$_SESSION['user']`中，没有其他会话安全措施（如会话固定攻击防护、会话超时等）。

**攻击步骤：**
1. 通过某种方式获取用户的会话ID
2. 使用该会话ID劫持用户会话

**具体思路：**
简单的会话管理机制容易受到会话劫持攻击。

### 6. 信息泄露

**漏洞描述：**
在`checklogin.php`中，登录成功后直接输出了flag变量的值，这在实际应用中会造成敏感信息泄露。

**攻击步骤：**
1. 成功登录系统
2. 系统会直接显示flag的值

**具体思路：**
敏感信息不应在前端直接暴露，这会泄露系统关键信息。

### 7. 错误信息处理不当

**漏洞描述：**
系统在遇到错误时直接输出错误信息，可能泄露系统内部信息。

**攻击步骤：**
1. 构造恶意输入触发系统错误
2. 分析返回的错误信息获取系统内部信息

**具体思路：**
详细的错误信息可能帮助攻击者了解系统结构和潜在漏洞。

### 修复建议：

1. **修复用户认证逻辑：**
   - 移除硬编码的查询条件，使用用户输入的用户名进行查询
   - 确保用户名和密码都来自用户输入并正确验证

2. **加强SQL注入防护：**
   - 确保所有数据库查询都使用参数化查询
   - 避免在查询中使用硬编码的条件

3. **改进输入过滤：**
   - 使用更严格的输入验证机制
   - 考虑使用白名单而非黑名单过滤

4. **安全存储密码：**
   - 使用强哈希算法（如bcrypt）存储密码
   - 添加盐值防止彩虹表攻击

5. **加强会话管理：**
   - 实现会话超时机制
   - 添加会话固定攻击防护
   - 使用安全的会话存储机制

6. **防止信息泄露：**
   - 不在前端直接输出敏感信息
   - 实现统一的错误处理机制，避免泄露系统内部信息

7. **改进错误处理：**
   - 实现统一的错误处理机制
   - 对用户隐藏详细的系统错误信息
   - 记录错误日志供管理员查看

通过以上分析，我们可以看到该系统存在多个严重的安全漏洞，需要进行全面的安全加固。
        