```
# n:0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
# e:65537
# enc:1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
# p>>128<<128:0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L
```


# BABYCRYPTO 高位泄露攻击 WP

## 题目信息
```
n: 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005L
e: 65537
enc: 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361
p>>128<<128: 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000L
```

## 考点分析

这是一个经典的**高位泄露攻击**题目，主要考查的知识点包括：
- RSA密码学基础
- Coppersmith攻击方法
- SageMath数学工具使用

## 解题思路

### 1. 理解题目信息
题目给出的信息中，最关键的是 `p>>128<<128` 这个表达式。这个表达式的含义是：
- 先将质因数p右移128位（丢弃低128位）
- 再将结果左移128位（在低位补0）

这样操作后，我们得到了p的高128位，而低128位被置为0。

### 2. 分析攻击方法
由于我们知道p的高128位信息，可以使用**Coppersmith攻击**来恢复完整的p值。

## 核心知识点详解

### 什么是Coppersmith攻击？

**通俗解释：**
想象你有一把巨大的数字密码锁，原本需要尝试几亿亿亿次才能打开。但是，现在有人告诉你密码的前几位是什么，那么你就不用全部猜了，只需要猜后面的几位数字。Coppersmith攻击就是这种思路在RSA加密中的应用。

**技术解释：**
Coppersmith攻击是一种基于格基约化（Lattice Reduction）的数学攻击方法，用于解决以下问题：
- 当RSA模数n的一个因数p的部分位数已知时，恢复完整的p
- 当RSA加密中的明文很小时，直接从密文恢复明文
- 当RSA的私钥指数d很小时，从公钥恢复私钥

**数学原理：**
Coppersmith方法利用了格（Lattice）的几何性质，通过构造一个多项式f(x)，使得f(x)的小整数根对应于我们想要找的值。然后使用LLL算法（Lenstra-Lenstra-Lovász）来找到多项式的"小根"。

### 什么是SageMath？

SageMath是一个开源的数学软件系统，专门用于数论、代数、几何等数学领域的计算。在CTF中，SageMath常用于：
- 大整数运算
- 有限域计算
- 格基约化（Lattice Reduction）
- 多项式运算

## 具体解题过程

### Step 1: SageMath脚本分析

让我们详细解释SageMath脚本的每一行：

```python
# 第一行：定义p的高位部分（已知信息）
p_high = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000

# 第二行：定义RSA模数n
n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005

# 第三行：在模n的多项式环中定义变量x
PR.<x> = PolynomialRing(Zmod(n))

# 解释：这行代码创建了一个多项式环，变量名为x，系数在模n的整数环Z/nZ中
# Zmod(n) 表示模n的整数环
# PolynomialRing() 创建多项式环
# <x> 表示定义变量x

# 第四行：构造多项式f(x) = p_high + x
f = p_high + x

# 解释：我们想要找的p = p_high + x，其中x是我们要找的未知低128位
# 当f(x) ≡ 0 (mod p) 时，意味着 (p_high + x) 是n的因数

# 第五行：使用Coppersmith方法寻找小根
x0 = f.small_roots(X=2^128, beta=0.4)[0]

# 解释：
# small_roots() - SageMath内置函数，实现Coppersmith方法
# X=2^128 - 表示我们寻找的小根x0满足 |x0| < 2^128
# beta=0.4 - 控制算法精度的参数，一般取值在0.4-0.5之间
# [0] - 取取第一个找到的根
```

### Step 2: 完整的SageMath解密脚本

```python
# 解密脚本 - solve.sage
print("=== Coppersmith高位泄露攻击 ===")

# 已知的p的高位部分
p_high = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b00000000000000000000000000000000

# RSA模数
n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005

print(f"已知p的高位部分: {hex(p_high)}")

# 在模n的多项式环中定义变量x
PR.<x> = PolynomialRing(Zmod(n))

# 构造多项式 f(x) = p_high + x
f = p_high + x

print("构造多项式完成，开始寻找小根...")

# 使用Coppersmith方法寻找小根
# X=2^128 表示未知数的范围是0到2^128
x0 = f.small_roots(X=2^128, beta=0.4)

if x0:
    x0 = x0[0]  # 取第一个根
    print(f"找到小根: {x0}")
    
    # 恢复完整的p值
    p = p_high + x0
    print(f"恢复的完整p值: {p}")
    print(f"p的十六进制: {hex(p)}")
    
    # 验证p确实是n的因数
    if n % p == 0:
        q = n // p
        print(f"q = n // p = {q}")
        print("验证成功：p是n的因数")
        
        # 保存结果到文件，供下一步Python脚本使用
        with open('results.txt', 'w') as f:
            f.write(f"p={p}\n")
            f.write(f"q={q}\n")
            f.write(f"n={n}\n")
    else:
        print("错误：p不是n的因数")
else:
    print("未找到小根")
```

### Step 3: 如何运行SageMath脚本

1. **安装SageMath**：
   - 方法1：使用Homebrew安装：`brew install sage`
   - 方法2：使用Docker：`docker run -it --rm sagemath/sagemath`
   - 方法3：使用在线SageMath（如CoCalc）

2. **运行脚本**：
   ```bash
   sage solve.sage
   ```

3. **如果系统中没有sage命令**：
   ```bash
   sage --python solve.sage
   # 或者
   /Applications/SageMath.app/Contents/Resources/sage/sage solve.sage
   ```

### Step 4: Python解密脚本

```python
# 解密脚本 - decrypt.py
import gmpy2
import binascii

print("=== RSA解密 ===")

# 读取SageMath脚本输出的结果
try:
    with open('results.txt', 'r') as f:
        lines = f.readlines()
        p = int(lines[0].split('=')[1].strip())
        q = int(lines[1].split('=')[1].strip())
        n = int(lines[2].split('=')[1].strip())
except FileNotFoundError:
    # 如果没有results.txt文件，使用已知的值
    print("使用已知的p值进行解密...")
    p = 160734387026849747944319274262095716650717626398118440194223452208652532694713113062084219512359968722796763029072117463281356654614167941930993838521563406258263299846297499190884495560744873319814150988520868951045961906000066805136724505347218275230562125457122462589771119429631727404626489634314291445667
    q = 13909135305901812842174475152508005653030796591829887569129999277548406442659158145699896831558234902707198720634065398892592346522547166189394439774429339126927412434518902881897700260059973246982416421836639972623337306974283973706200406124478741363829076759002937606461968542598069665590922549109000253893  # 通过n//p计算得到
    n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005

# RSA参数
e = 65537
c = 1422566584480199878714663051468143513667934216213366733442059106529451931078271460363335887054199577950679102659270179475911101747625120544429262334214483688332111552004535828182425152965223599160129610990036911146029170033592055768983427904835395850414634659565092191460875900237711597421272312032796440948509724492027247376113218678183443222364531669985128032971256792532015051829041230203814090194611041172775368357197854451201260927117792277559690205342515437625417792867692280849139537687763919269337822899746924269847694138899165820004160319118749298031065800530869562704671435709578921901495688124042302500361

print(f"质因数p: {p}")
print(f"质因数q: {q}")
print(f"验证 n = p * q: {p * q == n}")

# 计算欧拉函数 φ(n) = (p-1) * (q-1)
phi = (p - 1) * (q - 1)
print(f"欧拉函数φ(n): {phi}")

# 计算私钥 d = e^(-1) mod φ(n)
d = int(gmpy2.invert(e, phi))
print(f"私钥d: {d}")

# 解密 m = c^d mod n
print("开始解密...")
m = pow(c, d, n)
print(f"解密结果(十进制): {m}")
print(f"解密结果(十六进制): {hex(m)}")

# 将十六进制转换为字符串
try:
    # 移除十六进制字符串的'0x'前缀
    hex_str = hex(m)[2:]
    # 如果长度是奇数，前面补0
    if len(hex_str) % 2 == 1:
        hex_str = '0' + hex_str
    # 将十六进制字符串转换为字节串
    plaintext_bytes = bytes.fromhex(hex_str)
    # 将字节串转换为UTF-8字符串
    plaintext = plaintext_bytes.decode('utf-8')
    print(f"明文: {plaintext}")
except Exception as e:
    print(f"转换明文时出错: {e}")
    # 尝试其他编码
    try:
        # 尝试ASCII编码
        plaintext_ascii = plaintext_bytes.decode('ascii')
        print(f"ASCII解码结果: {plaintext_ascii}")
    except:
        print(f"十六进制明文: {hex_str}")
        print(f"字节串: {plaintext_bytes}")
```

### Step 5: 运行Python解密脚本

```bash
python3 decrypt.py
```

## 完整的解题流程

1. **分析题目**：理解`p>>128<<128`的含义
2. **选择工具**：使用SageMath进行Coppersmith攻击
3. **构造多项式**：f(x) = p_high + x
4. **寻找小根**：使用`small_roots()`函数
5. **计算完整p值**：p = p_high + x0
6. **计算q值**：q = n / p
7. **计算私钥**：d = e^(-1) mod φ(n)
8. **解密**：m = c^d mod n
9. **获取flag**：将解密结果转换为字符串

## 防护措施

1. **防止高位泄露**：在实际应用中，绝不能泄露RSA密钥的任何部分
2. **使用强随机数**：确保生成的质数具有足够的随机性
3. **密钥长度**：使用至少2048位的RSA密钥
4. **定期更换密钥**：定期更新密钥以减少风险

## 知识点总结

### Coppersmith攻击适用场景：
- 部分密钥泄露攻击（PKR）
- 小明文RSA攻击
- RSA-CRT实现中的错误攻击
- 相关消息攻击

### SageMath中常用的密码学函数：
- `PolynomialRing()` - 创建多项式环
- `small_roots()` - 寻找小根
- `Zmod(n)` - 模n的整数环
- `inverse_mod()` - 模逆元
- `is_prime()` - 素数检测

## 最终答案

运行完整的解密流程后，得到flag为：
```
flag{3d0914a1-1e97-4822-a745-c7e20c5179b9}
```

## 学习建议

对于这类CTF题目，建议：
1. 掌握RSA的基本数学原理
2. 了解常见的RSA攻击方法
3. 学会使用SageMath进行数学计算
4. 理解格基约化的基本概念
5. 多做练习来加深理解

希望这份详细的WP对您有帮助！



-----


