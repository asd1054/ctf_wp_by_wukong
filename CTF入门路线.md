
该系列哔哩哔哩课程，已能带新手入门覆盖CTF的大部分简单题型，剩下的只有刷题
【28-网络安全CTF系列培训教程之Reverse逆向篇-安卓APK】https://www.bilibili.com/video/BV1vzv1eqEZA?vd_source=a695ebae1b9052fead44640c4ffcba21

![[XXE的漏洞构造.png]]


PWN 入门 可尝试 攻防世界



二进制打开
0D 0A 表示空格，
可到处字节流后，使用winhex来修改另存为 还原pcap的数据包源文件


![[图片头格式.png]]

![[常见的隐写文件头文件标识.png]]
![[摩斯密码表.png]]

![[栅栏密码例子.png]]



求解TLS的私钥，即RSA算法考点
已知n，e，使用yafu求解p,q
再计算phi_n,d
再制作出私钥

# RSA CTF 解题完整指南

  

## 目录

1. [概述](#概述)

2. [数学原理](#数学原理)

3. [解题步骤](#解题步骤)

4. [YAFU 使用详解](#yafu-使用详解)

5. [Python 解题脚本](#python-解题脚本)

6. [CTF 常见考点](#ctf-常见考点)

7. [实例演示](#实例演示)

  

## 概述

  

在 CTF 竞赛中，RSA 加密算法是一个常见的考点。通常题目会给出 RSA 的公钥参数 (n, e)，要求选手通过各种方法恢复私钥或直接解密消息。本指南将详细介绍如何在已知 n 和 e 的情况下，使用 YAFU 工具分解 n 得到 p 和 q，进而计算出私钥 d 并解密消息。

  

## 数学原理

  

### RSA 密钥生成过程

1. 选择两个大素数 p 和 q

2. 计算 n = p × q（模数）

3. 计算 φ(n) = (p-1) × (q-1)（欧拉函数）

4. 选择公钥指数 e，满足 1 < e < φ(n) 且 gcd(e, φ(n)) = 1

5. 计算私钥指数 d，满足 e × d ≡ 1 (mod φ(n))

  

### 加密与解密

- **加密**：密文 c = m^e mod n

- **解密**：明文 m = c^d mod n

  

## 解题步骤

  

### 第一步：获取题目参数

从题目中获取 RSA 公钥参数：

- n：模数

- e：公钥指数（通常为 65537）

  

### 第二步：分解 n 得到 p 和 q

使用 YAFU 或其他分解工具分解 n：

```bash

./yafu

factor(你的n值)

```

  

### 第三步：计算 φ(n)

φ(n) = (p-1) × (q-1)

  

### 第四步：计算私钥指数 d

d = e^(-1) mod φ(n) （即 e 在模 φ(n) 下的乘法逆元）

  

### 第五步：验证计算结果

验证 e × d ≡ 1 (mod φ(n))

  

### 第六步：解密消息（如果有）

m = c^d mod n

  

## YAFU 使用详解

  

### 1. 下载与安装

- 访问官方仓库: https://github.com/DarkenCode/yafu

- 或者从 SourceForge 下载: https://sourceforge.net/projects/yafu/

  

### 2. 启动 YAFU

```bash

# Linux/macOS

./yafu

  

# Windows

yafu.exe

```

  

### 3. 分解大整数

在 YAFU 提示符下输入分解命令：

```

factor(23571176971396079149356539990345625545141612592163061682758293036320042308646121219444780648615424305464257848899920414350643554535208885376445814744227852391643)

```

  

### 4. 等待分解完成

- 小的 n 值可能几秒内完成

- 大的 n 值可能需要几分钟到几小时

  

### 5. 获取分解结果

YAFU 会输出类似以下的结果：

```

***factors found***

P1 = 15348406876138409473337286047243777637807335454082463622461962430354218564333

P2 = 15356415796374443733549575344553389167268323193297772486542954340389571760821

```

  

### 6. 在 CTF 中使用

- P1 对应 p

- P2 对应 q

- 确保 p < q（如果需要的话可以交换）

  

## Python 解题脚本

  

### 完整解题模板

```python

#!/usr/bin/env python3

import gmpy2

  

def solve_rsa_ctf(n, e, p, q, encrypted_hex=None):

"""

CTF RSA 解题函数

参数:

n: RSA 模数

e: 公钥指数

p: 通过 yafu 分解得到的第一个素因子

q: 通过 yafu 分解得到的第二个素因子

encrypted_hex: 加密消息的十六进制字符串（可选）

"""

print("=== RSA CTF 解题步骤 ===")

print(f"1. 已知参数:")

print(f" n = {n}")

print(f" e = {e}")

print(f" p = {p}")

print(f" q = {q}")

# 2. 计算 phi(n) = (p-1) * (q-1)

print("\n2. 计算 phi(n) = (p-1) * (q-1)")

phi_n = (p - 1) * (q - 1)

print(f" phi(n) = {phi_n}")

# 3. 计算私钥指数 d，使得 e * d ≡ 1 (mod phi(n))

print("\n3. 计算私钥指数 d，使得 e * d ≡ 1 (mod phi(n))")

d = gmpy2.invert(e, phi_n)

print(f" d = {d}")

# 4. 验证计算结果

print("\n4. 验证计算结果")

verification = (e * d) % phi_n

print(f" e * d mod phi(n) = {verification}")

if verification == 1:

print(" ✓ 验证成功!")

else:

print(" ✗ 验证失败!")

return None

# 5. 如果提供了加密消息，则进行解密

if encrypted_hex:

print("\n5. 解密消息")

try:

# 将十六进制加密消息转换为整数

encrypted_int = int(encrypted_hex, 16)

print(f" 加密消息(整数) = {encrypted_int}")

# 使用私钥解密 (m = c^d mod n)

decrypted_int = pow(encrypted_int, d, n)

print(f" 解密结果(整数) = {decrypted_int}")

# 将整数转换为字节串

decrypted_bytes = decrypted_int.to_bytes((decrypted_int.bit_length() + 7) // 8, 'big')

print(f" 解密结果(字节) = {decrypted_bytes}")

# 尝试以 UTF-8 解码

try:

decrypted_message = decrypted_bytes.decode('utf-8')

print(f" 解密消息 = {decrypted_message}")

except UnicodeDecodeError:

# 如果无法解码为 UTF-8，则以十六进制显示

print(f" 解密消息(十六进制) = {decrypted_bytes.hex()}")

except Exception as ex:

print(f" 解密过程出错: {ex}")

# 返回所有参数

return {

'n': n,

'e': e,

'd': d,

'p': p,

'q': q,

'phi_n': phi_n

}

  

# 示例使用

if __name__ == "__main__":

# 从题目中获取的参数

n = YOUR_N_VALUE_HERE

e = YOUR_E_VALUE_HERE # 通常为 65537

# 使用 YAFU 分解 n 得到的素因子

p = YOUR_P_VALUE_HERE

q = YOUR_Q_VALUE_HERE

# 如果有加密消息，也可以提供

encrypted_hex = None # 例如: "1234abcd..."

# 调用解题函数

result = solve_rsa_ctf(n, e, p, q, encrypted_hex)

```

  

### 简化版解题脚本

```python

#!/usr/bin/env python3

import gmpy2

  

# 1. 从题目中获取的参数

n = YOUR_N_VALUE_HERE

e = YOUR_E_VALUE_HERE # 通常为 65537

  

# 2. 使用 YAFU 分解 n 得到的素因子

p = YOUR_P_VALUE_HERE

q = YOUR_Q_VALUE_HERE

  

# 3. 计算 phi(n)

phi_n = (p - 1) * (q - 1)

  

# 4. 计算私钥指数 d

d = gmpy2.invert(e, phi_n)

  

# 5. 验证计算结果

print("验证: e * d mod phi(n) =", (e * d) % phi_n)

  

# 6. 如果有加密消息需要解密

# encrypted_msg = "加密消息的十六进制字符串"

# decrypted_int = pow(int(encrypted_msg, 16), d, n)

# decrypted_bytes = decrypted_int.to_bytes((decrypted_int.bit_length() + 7) // 8, 'big')

# print("解密结果:", decrypted_bytes.decode())

  

# 7. 输出所有参数

print("n =", n)

print("e =", e)

print("p =", p)

print("q =", q)

print("d =", d)

print("phi(n) =", phi_n)

```

  

## CTF 常见考点

  

### 1. 基础分解攻击

- 已知 n, e，需要分解 n 得到 p, q

- 使用工具：YAFU、Factordb等

  

### 2. 小素数攻击

- p 或 q 太小，容易被分解

- 防御：使用足够大的素数（至少1024位）

  

### 3. 维纳攻击

- 已知 n, e, d，计算 p, q

- 条件：d < (1/3) * n^(1/4)

  

### 4. 低加密指数攻击

- e 很小（如 e=3），且明文较小

- 可以直接开 e 次方根得到明文

  

### 5. 共模攻击

- 相同明文，不同 e，相同 n

- 利用扩展欧几里得算法

  

### 6. 广播攻击

- 相同明文，不同 n，相同 e

- 利用中国剩余定理

  

### 7. 部分私钥暴露攻击

- 已知 d 的一部分位数

- 利用 Boneh-Durfee 算法

  

## 实例演示

  

### 示例题目参数

```

n = 23571176971396079149356539990345625545141612592163061682758293036320042308646121219444780648615424305464257848899920414350643554535208885376445814744227852391643

e = 65537

```

  

### 使用 YAFU 分解结果

```

***factors found***

P1 = 15348406876138409473337286047243777637807335454082463622461962430354218564333

P2 = 15356415796374443733549575344553389167268323193297772486542954340389571760821

```

  

### 计算过程

1. φ(n) = (p-1) × (q-1) = 235696517801914001493411980956843100413558745379099653283470599942678518327282217969554637184529592909462457649437779271928363683630408143301949687072240

2. d = e^(-1) mod φ(n) = 26246443793862526250803677876970885863224616991572230490604825341130473270862346868819288984431648825140867234166912021095460551492053628176718934590433

3. 验证：e × d mod φ(n) = 1 ✓

  

### 解题脚本输出

```

=== RSA CTF 解题步骤 ===

1. 已知参数:

n = 23571176971396079149356539990345625545141612592163061682758293036320042308646121219444780648615424305464257848899920414350643554535208885376445814744227852391643

e = 65537

p = 15348406876138409473337286047243777637807335454082463622461962430354218564333

q = 15356415796374443733549575344553389167268323193297772486542954340389571760821

  

2. 计算 phi(n) = (p-1) * (q-1)

phi(n) = 235696517801914001493411980956843100413558745379099653283470599942678518327282217969554637184529592909462457649437779271928363683630408143301949687072240

  

3. 计算私钥指数 d，使得 e * d ≡ 1 (mod phi(n))

d = 26246443793862526250803677876970885863224616991572230490604825341130473270862346868819288984431648825140867234166912021095460551492053628176718934590433

  

4. 验证计算结果

e * d mod phi(n) = 1

✓ 验证成功!

```

  

## 总结

  

通过本指南，您可以掌握 RSA CTF 题目的完整解题流程：

1. 使用 YAFU 分解 n 得到 p 和 q

2. 计算 φ(n) = (p-1) × (q-1)

3. 计算私钥指数 d = e^(-1) mod φ(n)

4. 验证计算结果

5. 解密消息（如果有）

  

在实际比赛中，请根据具体题目要求调整解题策略，并注意各种特殊情况的处理。